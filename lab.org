#+Title: Laboratórios de Micro controladores
#+Author: Lucas Valandro da Rocha
#+Email: lucas.valandrorocha@inf.ufrgs.br
#+Language: pt

* LAB01 (2020-06-01 / 2020-06-04)
** Setup do cartão microSD
*** Download da imagem
       
    https://downloadmirror.intel.com/26418/eng/Galileo_Poky_SW_image_20160606.zip

*** Descompactando arquivo no cartão microsd
  *MAC OSX*
    
   diskutil list
    
   -  Ache o seu cartão sd, no meu caso, */dev/disk2*

   - Instale o pacote coreutils através do HomeBrew

   brew install coreutils

   - Execute o seguinte comando

   unzip -p Galileo...zip | sudo gdd of=/dev/disk2 bs=3m conv=fsync status=progress

   - Após a instalação, basta inserir o cartão na Galileo

   OBS.: Caso receba uma mensagem estilo "Resource busy", você deve
   então:

   diskutil unmountDisk force /dev/disk2

*** Boot da Galileo
    
   Após inserir o cartão SD e conectar sua placa no seu roteador,
   então é necessário encontrar sua Galileo na rede local.

   Para encontrar a Galileo na sua rede, você pode utilizar os seguintes comandos:

   - Visualização da tabela ARP e procura do MAC addr da Galileo
      
   arp -a

   - Procura pelo IP na rede

   Instale o pacote ip via HomeBrew

   brew install iproute2mac

   Após instalação, basta:
   
   ip neighbor


*** Configuração de acesso rápido
  
  Após descobrir o IP da galileo em sua rede, é uma boa prática
  configurar acesso via ssh de maneira rápida, para isso:

  - Utilize o comando para gerar (caso não possua) uma chave pública

  ssh-keygen 

  - Copie essa chave para dentro da Galileo com o comando

  scp ~/.ssh/id_rsa.pub root@<galileo-ip>

  - Acesse a Galileo e guarde essa chave no local adequado

  mkdir .ssh
  
  cat id_ras.pub >> .ssh/authorized_keys

  - Feito, basta sair com o comando *exit*

* LAB02 (2020-06-06)
** Configuração do ambiente de desenvolvimento
*** Download do Intel System Studio IoT Edition e configuração

  *Note: A partir daqui o tutorial está sendo executado em uma VM de Linux por questões de incompatibilidade com o MacOS*

  http://www.ece.ufrgs.br/~fetter/eng10032/iss-iot-linux_03-24-16.tar.bz2

  - Descompacte o arquivo no diretorio /opt

  cd /opt

  - Dê permissões aos arquivos descompactados

  chown -R root.root iss-iot-linux

  chmod -R go-w iss-iot-linux

  chmod -R -s iss-iot-linux

  - Ainda no mesmo diretório crie um link para a versão atual do I.S.S
    IoT

  ln -s iss-iot-linux iot-devkit

  - Crie um link para o diretório de ferramentas de desenvolvimento

  cd iot-devkit
  ln -s devkit-x86 1.7.2

  - Alterar o arquivo *iot-devkit/sdk-relocator/relocate_sdk.sh*

  De *find* para *gfind*

  - Execute o comando utilizando o diretório que você instalou o ambiente

  INSTALL_DIR="/Users/valandro/galileo/iot-devkit" sdk-relocator/relocate_sdk.sh

** Experimentos
*** Configurando as variáveis de ambiente 

  export DEVKIT=$HOME/galileo/iot-devkit/devkit-x86

  export PATH=$PATH:$DEVKIT/sysroots/x86_64-pokysdk-linux/usr/bin/i586-poky-linux/

  export CROSS_COMPILE=i586-poky-linux-

  export ARCH=x86

*** Executando o primeiro programa na Galileo

  Crie um diretório para salvar os primeiros arquivos do projeto.

  Makefile

  #+BEGIN_SRC C
  TARGET=hello
  SRCS=$(TARGET).c

  FLAGS=-O2 -Wall -g -MMD
  INCLUDE=-I.
  LIBDIR=
  LIBS=

  CC=$(CROSS_COMPILE)gcc
  CFLAGS=$(FLAGS) $(INCLUDE)
  LDFLAGS=$(LIBDIR) $(LIBS)

  all: $(TARGET)

  $(TARGET): $(SRCS:.c=.o)
		$(CC) -o $@ $^ $(LDFLAGS)

  %.o: %.c
		$(CC) $(CFLAGS) -c -o $@ $<

  -include $(SRCS:.c=.d) 22
  clean:
		rm -f *~ *.bak *.o *.d

  distclean: clean
		rm -f $(TARGET)

  #+END_SRC

  hello.c

  #+BEGIN_SRC C
  #include <stdio.h>
  int main(int argc, char *argv[]) {
    printf("Hello, world!\n");

    return 0;
  }
  #+END_SRC
 

  Basta executar o comando *make*

  Copie o executável para sua galileo através do comando

  scp hello <user>@<ip>:

  Entre na galileo e execute para constatar seu funcionamento.

*** Criando um segundo programa para a Galileo

  A ideia é criar um hello world em C++, fazendo adaptações no
  Makefile existente.

  #+BEGIN_SRC C
  TARGET=hello
  SRCS=$(TARGET).cpp

  FLAGS=-O2 -Wall -g -MMD
  INCLUDE=-I.
  LIBDIR=
  LIBS=

  CPP=$(CROSS_COMPILE)g++
  CFLAGS=$(FLAGS) $(INCLUDE)
  LDFLAGS=$(LIBDIR) $(LIBS)

  all: $(TARGET)

  $(TARGET): $(SRCS:.cpp=.out)
		$(CPP) -o $@ $^ $(LDFLAGS)

  %.out: %.cpp
		$(CPP) $(CFLAGS) -c -o $@ $<

  -include $(SRCS:.cpp=.d) 22

  clean:
		rm -f *~ *.out *.d

  distclean: clean
		rm -f $(TARGET)

  #+END_SRC

  #+BEGIN_SRC CPP
  #include <iostream>

  int main() {
	std::cout << "Hello World!\n";
	return 0;
  }
  #+END_SRC
