#+Title: Laboratórios de Micro controladores
#+Author: Lucas Valandro da Rocha
#+Email: lucas.valandrorocha@inf.ufrgs.br
#+Language: pt

* LAB01 (2020-06-01 / 2020-06-04)
** Setup do cartão microSD
*** Download da imagem
       
    https://downloadmirror.intel.com/26418/eng/Galileo_Poky_SW_image_20160606.zip

*** Descompactando arquivo no cartão microsd
  *MAC OSX*
    
   diskutil list
    
   -  Ache o seu cartão sd, no meu caso, */dev/disk2*

   - Instale o pacote coreutils através do HomeBrew

   brew install coreutils

   - Execute o seguinte comando

   unzip -p Galileo...zip | sudo gdd of=/dev/disk2 bs=3m conv=fsync status=progress

   - Após a instalação, basta inserir o cartão na Galileo

   OBS.: Caso receba uma mensagem estilo "Resource busy", você deve
   então:

   diskutil unmountDisk force /dev/disk2

*** Boot da Galileo
    
   Após inserir o cartão SD e conectar sua placa no seu roteador,
   então é necessário encontrar sua Galileo na rede local.

   Para encontrar a Galileo na sua rede, você pode utilizar os seguintes comandos:

   - Visualização da tabela ARP e procura do MAC addr da Galileo
      
   arp -a

   - Procura pelo IP na rede

   Instale o pacote ip via HomeBrew

   brew install iproute2mac

   Após instalação, basta:
   
   ip neighbor

*** Configuração de acesso rápido
  
  Após descobrir o IP da galileo em sua rede, é uma boa prática
  configurar acesso via ssh de maneira rápida, para isso:

  - Utilize o comando para gerar (caso não possua) uma chave pública

  ssh-keygen 

  - Copie essa chave para dentro da Galileo com o comando

  scp ~/.ssh/id_rsa.pub root@<galileo-ip>

  - Acesse a Galileo e guarde essa chave no local adequado

  mkdir .ssh
  
  cat id_ras.pub >> .ssh/authorized_keys

  - Feito, basta sair com o comando *exit*

* LAB02 (2020-06-06)
** Configuração do ambiente de desenvolvimento
*** Download do Intel System Studio IoT Edition e configuração

  *Note: A partir daqui o tutorial está sendo executado em uma VM de Linux por questões de incompatibilidade com o MacOS*

  http://www.ece.ufrgs.br/~fetter/eng10032/iss-iot-linux_03-24-16.tar.bz2

  - Descompacte o arquivo no diretorio /opt

  cd /opt

  - Dê permissões aos arquivos descompactados

  chown -R root.root iss-iot-linux

  chmod -R go-w iss-iot-linux

  chmod -R -s iss-iot-linux

  - Ainda no mesmo diretório crie um link para a versão atual do I.S.S
    IoT

  ln -s iss-iot-linux iot-devkit

  - Crie um link para o diretório de ferramentas de desenvolvimento

  cd iot-devkit
  ln -s devkit-x86 1.7.2

  - Alterar o arquivo *iot-devkit/sdk-relocator/relocate_sdk.sh*

  De *find* para *gfind*

  - Execute o comando utilizando o diretório que você instalou o ambiente

  INSTALL_DIR="/Users/valandro/galileo/iot-devkit" sdk-relocator/relocate_sdk.sh

** Experimentos
*** Configurando as variáveis de ambiente 

  export DEVKIT=$HOME/galileo/iot-devkit/devkit-x86

  export PATH=$PATH:$DEVKIT/sysroots/x86_64-pokysdk-linux/usr/bin/i586-poky-linux/

  export CROSS_COMPILE=i586-poky-linux-

  export ARCH=x86

*** Executando o primeiro programa na Galileo

  Crie um diretório para salvar os primeiros arquivos do projeto.

  Makefile

  #+BEGIN_SRC c
  TARGET=hello
  SRCS=$(TARGET).c

  FLAGS=-O2 -Wall -g -MMD
  INCLUDE=-I.
  LIBDIR=
  LIBS=

  CC=$(CROSS_COMPILE)gcc
  CFLAGS=$(FLAGS) $(INCLUDE)
  LDFLAGS=$(LIBDIR) $(LIBS)

  all: $(TARGET)

  $(TARGET): $(SRCS:.c=.o)
		$(CC) -o $@ $^ $(LDFLAGS)

  %.o: %.c
		$(CC) $(CFLAGS) -c -o $@ $<

  -include $(SRCS:.c=.d) 22
  clean:
		rm -f *~ *.bak *.o *.d

  distclean: clean
		rm -f $(TARGET)

  #+END_SRC

  hello.c

  #+BEGIN_SRC c
  #include <stdio.h>
  int main(int argc, char *argv[]) {
    printf("Hello, world!\n");

    return 0;
  }
  #+END_SRC
 

  Basta executar o comando *make*

  Copie o executável para sua galileo através do comando

  scp hello <user>@<ip>:

  Entre na galileo e execute para constatar seu funcionamento.

*** Criando um segundo programa para a Galileo

  A ideia é criar um hello world em C++, fazendo adaptações no
  Makefile existente.

  #+BEGIN_SRC c
  TARGET=hello
  SRCS=$(TARGET).cpp

  FLAGS=-O2 -Wall -g -MMD
  INCLUDE=-I.
  LIBDIR=
  LIBS=

  CPP=$(CROSS_COMPILE)g++
  CFLAGS=$(FLAGS) $(INCLUDE)
  LDFLAGS=$(LIBDIR) $(LIBS)

  all: $(TARGET)

  $(TARGET): $(SRCS:.cpp=.out)
		$(CPP) -o $@ $^ $(LDFLAGS)

  %.out: %.cpp
		$(CPP) $(CFLAGS) -c -o $@ $<

  -include $(SRCS:.cpp=.d) 22

  clean:
		rm -f *~ *.out *.d

  distclean: clean
		rm -f $(TARGET)

  #+END_SRC
  #+BEGIN_SRC c++
  #include <iostream>

  int main() {
	std::cout << "Hello World!\n";
	return 0;
  }
  #+END_SRC
* LAB03 (2020-06-14 / 2020-06-20)
** Utilizando pinos de I/O
*** Explicação sobre pinos de I/O na Galileo e seu funcionamento

   GPIO: General-purpose input/output


   Cada pino conector de *shield* possui várias funções, e para
   utilizá-los é necessários configurar seus multiplexadores para
   obter o efeito desejado.
 

   Pinos:
   - IO2 e IO3 => Quando configurados como GPIO são comandados
     diretamente pelo Quark X1000.
   - A0 -> A5 => São compartilhados com o conversor A/D, podem ser
     configurados apenas para saída, além de terem capacitores de
     *150nF* em suas saídas.
   - IO0 -> IO6 e IO9-IO13 => Quando configurados como GPIO são
     comandados diretamente pelo Quark X1000, os demais são obtidos
     através de expansores, e por isso possuem *latência maior*.


   Ou seja, algumas portas GPIO estão disponíveis no conector de
   shield e outras são usadas internamente na Galileo para controlar 
   os multiplexadores.

   Para tanto, a *Galileo Gen2* possui 3 expansores de GPIO PCAL9535A
   conectados ao Quark X1000 através do barramento I2C nos endereços
   *0x25, 0x26 e 0x27*.
   
*** Acesso às Portas GPIO

   Para utilizar os pinos de I/O no conector de shield da Galileo Gen2
   é necessário configurar:

   - O(s) multiplexador(es) que conectam o pino no conector ao Quark
     ou ao chip da Galileo que provê a funcionalidade desejada.
   - A direção do buffer associado ao sinal. *(Na Galileo Gen2)*
   - Se um resistor de pull-up ou pull-down de 22k ohm deve ser
     conectado ao pino. *(Gen1 o resistor é de 5.6k ohm)*
   - A direção do sinal.

   *NOTE QUE* na Galileo Gen2 deve-se configurar *independentemente* a
   direção do buffer e a direção do pino de GPIO. Uma tabela com o
   mapeamento de I/O está disponível no Moodle.

*** Configuração dos Pinos do Shield para uso como GPIO

  Na *Galileo Gen2* para configurar o pino *IO13* como saída digital,
  pode-se verificar, através da tabela de mapeamento de pinos de I/O,
  que deve-se configurar os *gpio46* e *gpio30* como saída em *nível*
  *lógico baixo*, enquanto o *gpio31* controla se será usado ou não o
  resistor de pull-up ou pull-down e, finalmente o *gpio7* controla o
  sinal que aparecerá no pino *IO13*.

  Para configurar um determinado *gpio*, é necessário primeiro exportar
  a porta. Isto é feito escrevendo o número (em ASCII) da porta *GPIO*
  em */sys/class/gpio/export*. Por exemplo, usando comandos do shell:

  #+BEGIN_SRC shell

  echo -n "46" > /sys/class/gpio/export

  #+END_SRC

  Com isso surgirá um diretório correspondente à porta. No caso, em
  */sys/class/gpio/gpio46*. A direção da porta é controlada escrevendo
  "in" ou "out" em */sys/class/gpio/gpioXX/direction*.


  #+BEGIN_SRC shell
  
  echo -n "out" > /sys/class/gpio/gpio46/direction
  
  #+END_SRC


  Para escrever ou ler uma porta GPIO, pode-se utilizar os comandos a
  seguir:

  #+BEGIN_SRC shell

  echo -n "0" > /sys/class/gpio/gpio46/value

  ou 

  cat /sys/class/gpio/gpio46/value

  #+END_SRc

  Para as portas que controlam os *multiplexadores* ou direção dos
  buffers também é possível escrever "low" ou "high" no pseudo-arquivo
  *direction*. Isso é equivalente a configurar simultaneamente *direction*
  para "out" e *value* para "0" ou "1".

  Quando a porta I/O *não for mais utilizada* basta "desexportar"
  escrevendo em:


  #+BEGIN_SRC shell

  echo -n "46" > /sys/class/gpio/unexport

  #+END_SRC

*** Ajuste das permissões

  Por default, os arquivos em /sys/class/gpio só podem ser escritos
  pelo superusuário. Isso iria requerer que todos usuários que
  utilizassem o GPIO tivessem permissões de superusuário, o que não é
  uma boa ideia por questões de segurança.

  Uma alternativa para esse problema é criar um grupo chamado *gpio* e
  dar as devidas permissões para os arquivos /sys/class/gpio.

  Criando um novo usuário na Galileo, primeiro acesso como *root*.

  #+BEGIN_SRC shell

  sudo useradd <username>

  sudo passwd <username>

  #+END_SRC

  Obs.: Talvez seja necessário adicionar sua chave pública no folder
  .ssh desse novo usuário.

  O script abaixo demonstra como configurar o pino *IO13* como saída e
  ajusta as permissões para que possa ser controlado por usuários que
  pertençam ao grupo *gpio*. Note que os comentários não são meramente
  informativo, eles são necessários para correta interpretação do
  programa.

  
  #+NAME eng1002lab03_1
  #+BEGIN_SRC shell
  #! /bin/sh
  ### BEGIN INIT INFO
  # Provides:          eng10032lab03_1
  # Required-Start:    
  # Should-Start:      
  # Required-Stop:     
  # Default-Start:     S
  # Default-Stop:
  # Short-Description: Configures GPIO for Lab 03.
  # Description:       Configures GPIO for Lab 03.
  ### END INIT INFO

  boardId=`cat /sys/devices/virtual/dmi/id/board_name`

  case "$1" in
    start|restart|force-reload)
      case $boardId in
	"Galileo")
	  if [ ! -d /sys/class/gpio/gpio55 ] ; then
	      echo -n "55" > /sys/class/gpio/export
	  fi
	  echo -n "out" > /sys/class/gpio/gpio55/direction
	  echo -n "1" > /sys/class/gpio/gpio55/value

	  if [ ! -d /sys/class/gpio/gpio39 ] ; then
	      echo -n "39" > /sys/class/gpio/export
	  fi
	  echo -n "out" > /sys/class/gpio/gpio39/direction
	  echo -n "strong" > /sys/class/gpio/gpio39/drive
	  chgrp gpio /sys/class/gpio/gpio39/value
	  chmod g+rw /sys/class/gpio/gpio39/value

	  # IO13 LED is not mounted. Use the one at gpio3
	  if [ ! -d /sys/class/gpio/gpio3 ] ; then
	      echo -n "3" > /sys/class/gpio/export
	  fi
	  echo -n "out" > /sys/class/gpio/gpio3/direction
	  chgrp gpio /sys/class/gpio/gpio3/value
	  chmod g+rw /sys/class/gpio/gpio3/value
	  ;;
	"GalileoGen2")
	  if [ ! -d /sys/class/gpio/gpio46 ] ; then
	      echo -n "46" > /sys/class/gpio/export
	  fi
	  echo -n "out" > /sys/class/gpio/gpio46/direction
	  echo -n "0" > /sys/class/gpio/gpio46/value

	  if [ ! -d /sys/class/gpio/gpio30 ] ; then
	      echo -n "30" > /sys/class/gpio/export
	  fi
	  echo -n "out" > /sys/class/gpio/gpio30/direction
	  echo -n "0" > /sys/class/gpio/gpio30/value

	  if [ ! -d /sys/class/gpio/gpio7 ] ; then
	      echo -n "7" > /sys/class/gpio/export
	  fi
	  echo -n "out" > /sys/class/gpio/gpio7/direction
	  chgrp gpio /sys/class/gpio/gpio7/value
	  chmod g+rw /sys/class/gpio/gpio7/value
	  ;;
      esac
      ;;
    stop)
      case $boardId in
	"Galileo")
	  echo -n "in" > /sys/class/gpio/gpio39/direction
	  echo -n "39" > /sys/class/gpio/unexport
	  echo -n "55" > /sys/class/gpio/unexport
	  echo -n "3" > /sys/class/gpio/unexport
	  ;;
	"GalileoGen2")
	  echo -n "in" > /sys/class/gpio/gpio7/direction
	  echo -n "7" > /sys/class/gpio/unexport
	  echo -n "1" > /sys/class/gpio/gpio30/value
	  echo -n "30" > /sys/class/gpio/unexport
	  echo -n "46" > /sys/class/gpio/unexport
	  ;;
      esac
      ;;
    status)
	  ls -d /sys/class/gpio/gpio*
	  ;;
    ,*)

	echo -n "Usage: $0 " 
	echo "{start|stop|restart|force-reload|status}"
	exit 1
	;;
     esac
  exit 0
  #+END_SRC
** Experimentos
*** Configuração da Galileo para Usar GPIO
   
   O primeiro copie para Galileo o script *eng10032lab03_1*

   #+BEGIN_SRC shell

   scp eng10032lab03_1 <username>@<ip>:  
 
   #+END_SRC

   Agora, acesse a Galileo como *superusuário* e adicione seu usuário no grupo *gpio*
   
   #+BEGIN_SRC shell

   groupadd -r gpio

   groupmems -g gpio -a <username>

   #+END_SRC

   Copie o arquivo para o diretório /etc/init.d na galileo com o
   comando:

   #+BEGIN_SRC shell
   
   cp ~/eng10032lab03_1 /etc/init.d   

   #+END_SRC

   Torne o *script* executável com o comando:

   #+BEGIN_SRC shell

   chmod +x /etc/init.d/en10032lab03_1

   #+END_SRC


   Configure o linux para executar o script durante a inicialização

   #+BEGIN_SRC shell

   update-rc.d eng10032lab031_1 defaults

   #+END_SRC

   E por fim, reinicialize a Galileo

   #+BEGIN_SRC shell

   reboot

   #+END_SRC
*** Uso dos pinos de GPIO
  
   Na Galileo Gen2 o pino *IO13* (onde está conectado o LED) é controlado
   pela porta *gpio7*, que é roteada para esse pino colocando a *gpio46* em
   nível lógico baixo. A *gpio30* controla a direção do buffer associado
   (nível lógico *baixo* para saída e *alto* para entrada). Neste caso, é
   irrelevante o estado do resistor de /pull-up/ ou /pull-down/ controlado
   pelo *gpio31*.

   Antes de realizar criar os programas, é necessário configurar
   um script que será executado no momento da inicialização da
   Galileo. Esse script servirá para configuração dos pinos de *GPIO* que
   serão utilizados pelo seu programa. *É necessário excluir essa*
   *configuração assim que terminar de executar seus programas, para que*
   *as portas estejam acessíveis futuramente.*

   Para adicionar esses scripts, entre como super usuário na Galileo e:

   #+BEGIN_SRC shell

   cp script /etc/init.d
   chmod +x /etc/init.d/script
   update-rc.d script defaults

   #+END_SRC


   E para excluir esse script da inicialização basta:

   #+BEGIN_SRC shell

   update-rc.d -f script remove

   #+END_SRC

**** Piscando o LED do pino IO13

    Primeiro, configure o arquivo /eng10032lab03_1/ na Galileo

    #+BEGIN_SRC shell
    #! /bin/sh
    ### BEGIN INIT INFO
    # Provides:          eng10032lab03_1
    # Required-Start:    
    # Should-Start:      
    # Required-Stop:     
    # Default-Start:     S
    # Default-Stop:
    # Short-Description: Configures GPIO for Lab 03.
    # Description:       Configures GPIO for Lab 03.
    ### END INIT INFO

    boardId=`cat /sys/devices/virtual/dmi/id/board_name`

    case "$1" in
      start|restart|force-reload)
	case $boardId in
	  "Galileo")
	    if [ ! -d /sys/class/gpio/gpio55 ] ; then
		echo -n "55" > /sys/class/gpio/export
	    fi
	    echo -n "out" > /sys/class/gpio/gpio55/direction
	    echo -n "1" > /sys/class/gpio/gpio55/value

	    if [ ! -d /sys/class/gpio/gpio39 ] ; then
		echo -n "39" > /sys/class/gpio/export
	    fi
	    echo -n "out" > /sys/class/gpio/gpio39/direction
	    echo -n "strong" > /sys/class/gpio/gpio39/drive
	    chgrp gpio /sys/class/gpio/gpio39/value
	    chmod g+rw /sys/class/gpio/gpio39/value

	    # IO13 LED is not mounted. Use the one at gpio3
	    if [ ! -d /sys/class/gpio/gpio3 ] ; then
		echo -n "3" > /sys/class/gpio/export
	    fi
	    echo -n "out" > /sys/class/gpio/gpio3/direction
	    chgrp gpio /sys/class/gpio/gpio3/value
	    chmod g+rw /sys/class/gpio/gpio3/value
	    ;;
	  "GalileoGen2")
	    if [ ! -d /sys/class/gpio/gpio46 ] ; then
		echo -n "46" > /sys/class/gpio/export
	    fi
	    echo -n "out" > /sys/class/gpio/gpio46/direction
	    echo -n "0" > /sys/class/gpio/gpio46/value

	    if [ ! -d /sys/class/gpio/gpio30 ] ; then
		echo -n "30" > /sys/class/gpio/export
	    fi
	    echo -n "out" > /sys/class/gpio/gpio30/direction
	    echo -n "0" > /sys/class/gpio/gpio30/value

	    if [ ! -d /sys/class/gpio/gpio7 ] ; then
		echo -n "7" > /sys/class/gpio/export
	    fi
	    echo -n "out" > /sys/class/gpio/gpio7/direction
	    chgrp gpio /sys/class/gpio/gpio7/value
	    chmod g+rw /sys/class/gpio/gpio7/value
	    ;;
	esac
	;;
      stop)
	case $boardId in
	  "Galileo")
	    echo -n "in" > /sys/class/gpio/gpio39/direction
	    echo -n "39" > /sys/class/gpio/unexport
	    echo -n "55" > /sys/class/gpio/unexport
	    echo -n "3" > /sys/class/gpio/unexport
	    ;;
	  "GalileoGen2")
	    echo -n "in" > /sys/class/gpio/gpio7/direction
	    echo -n "7" > /sys/class/gpio/unexport
	    echo -n "1" > /sys/class/gpio/gpio30/value
	    echo -n "30" > /sys/class/gpio/unexport
	    echo -n "46" > /sys/class/gpio/unexport
	    ;;
	esac
	;;
      status)
	    ls -d /sys/class/gpio/gpio*
	    ;;
      *)
	    echo -n "Usage: $0 " 
	    echo "{start|stop|restart|force-reload|status}"
	    exit 1
	    ;;
    esac

    exit 0
    #+END_SRC

    Após isso e realizar o /reboot/ dela, ative o cross compiler através
    do script de configuração e então compile o seguinte código.

    #+BEGIN_SRC c
    /*
      blink.c: Blinks a LED on Galileog gpio3 or Galileo Gen2 IO13.

      Copyright (c) 2016, 2020 Walter Fetter Lages <w.fetter@ieee.org>

	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; either version 2 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

	You can also obtain a copy of the GNU General Public License
	at <http://www.gnu.org/licenses>.

    */

    #include <fcntl.h>
    #include <string.h>
    #include <unistd.h>

    int main(int argc,char *argv[])
    {
	    char state='0';
	    int fd;
	    char s[20];
	    int n;

	    fd=open("/sys/devices/virtual/dmi/id/board_name",O_RDONLY);
	    n=read(fd,s,sizeof s);
	    close(fd);
	    s[n-1]='\0'; /* Discards new line */

	    if(strncmp(s,"Galileo",sizeof s) == 0)
		fd=open("/sys/class/gpio/gpio3/value",O_WRONLY);
	    else if(strncmp(s,"GalileoGen2",sizeof s) == 0)
		fd=open("/sys/class/gpio/gpio7/value",O_WRONLY);
	    else return -1;

	    for(;;)
	    {	
		    lseek(fd,0,SEEK_SET);
		    write(fd,&state,sizeof state);
		    sleep(1);
		    state^='0'^'1';
	    }

	    close(fd);

	    return 0;
    }
    #+END_SRC 

    Esse trecho de código fará a luz de LED mais próxima do conector
    microusb piscar em intervalos de *1 segundo*.

**** Piscando o LED do pino IO3

   Alterar os pinos, colocar script de inicialização na Galileo

   A ideia de configurar o pino de *IO3* era de criarmos um circuito com
   um push button que iria desabilitar o LED assim que fosse
   apertado. Para isso, foi necessário olhar o mapeamento das portas
   da *Galileo Gen2* e configurar um novo script de inicialização das
   portas, conforme nossa necessidade de utilizarmos a porta *IO3* como
   output para ligar o LED e a porta *IO2* como input do clique do
   botão.

   #+BEGIN_SRC shell

   #! /bin/sh
   ### BEGIN INIT INFO
   # Provides:          eng10032lab03_1
   # Required-Start:    
   # Should-Start:      
   # Required-Stop:     
   # Default-Start:     S
   # Default-Stop:
   # Short-Description: Configures GPIO for Lab 03.
   # Description:       Configures GPIO for Lab 03.
   ### END INIT INFO

   boardId=`cat /sys/devices/virtual/dmi/id/board_name`

   case "$1" in
     start|restart|force-reload)
       case $boardId in
	 "Galileo")
	   if [ ! -d /sys/class/gpio/gpio55 ] ; then
	       echo -n "55" > /sys/class/gpio/export
	   fi
	   echo -n "out" > /sys/class/gpio/gpio55/direction
	   echo -n "1" > /sys/class/gpio/gpio55/value

	   if [ ! -d /sys/class/gpio/gpio39 ] ; then
	       echo -n "39" > /sys/class/gpio/export
	   fi
	   echo -n "out" > /sys/class/gpio/gpio39/direction
	   echo -n "strong" > /sys/class/gpio/gpio39/drive
	   chgrp gpio /sys/class/gpio/gpio39/value
	   chmod g+rw /sys/class/gpio/gpio39/value

	   # IO13 LED is not mounted. Use the one at gpio3
	   if [ ! -d /sys/class/gpio/gpio3 ] ; then
	       echo -n "3" > /sys/class/gpio/export
	   fi
	   echo -n "out" > /sys/class/gpio/gpio3/direction
	   chgrp gpio /sys/class/gpio/gpio3/value
	   chmod g+rw /sys/class/gpio/gpio3/value
	   ;;
	 "GalileoGen2")
	   if [ ! -d /sys/class/gpio/gpio76 ] ; then
	       echo -n "76" > /sys/class/gpio/export
	   fi
	   echo -n "out" > /sys/class/gpio/gpio76/direction
	   echo -n "0" > /sys/class/gpio/gpio76/value

	   if [ ! -d /sys/class/gpio/gpio16 ] ; then
	       echo -n "16" > /sys/class/gpio/export
	   fi
	   echo -n "out" > /sys/class/gpio/gpio16/direction
	   echo -n "0" > /sys/class/gpio/gpio16/value

	   if [ ! -d /sys/class/gpio/gpio14 ] ; then
	       echo -n "14" > /sys/class/gpio/export
	   fi
	   echo -n "out" > /sys/class/gpio/gpio14/direction
	   chgrp gpio /sys/class/gpio/gpio14/value
	   chmod g+rw /sys/class/gpio/gpio14/value

	   # IO2 LED input
	   if [ !d /sys/class/gpio/gpio77 ] ; then
		   echo -n "77" > /sys/class/gpio/export
	   fi
	   echo -n "in" > /sys/class/gpio/gpio77/direction
	   echo -n "1" > /sys/class/gpio/gpio77/value

	   if [ !d /sys/class/gpio/gpio34 ] ; then
		   echo -n "34" > /sys/class/gpio/export
	   fi
	   echo -n "in" > /sys/class/gpio/gpio34/direction
	   echo -n "1" > /sys/class/gpio/gpio34/value

	   if [ ! -d /sys/class/gpio/gpio13 ] ; then
	       echo -n "13" > /sys/class/gpio/export
	   fi
	   echo -n "in" > /sys/class/gpio/gpio13/direction
	   chgrp gpio /sys/class/gpio/gpio13/value
	   chmod g+rw /sys/class/gpio/gpio13/value
	   ;;
       esac
       ;;
     stop)
       case $boardId in
	 "Galileo")
	   echo -n "in" > /sys/class/gpio/gpio39/direction
	   echo -n "39" > /sys/class/gpio/unexport
	   echo -n "55" > /sys/class/gpio/unexport
	   echo -n "3" > /sys/class/gpio/unexport
	   ;;
	 "GalileoGen2")
	   echo -n "in" > /sys/class/gpio/gpio14/direction
	   echo -n "14" > /sys/class/gpio/unexport
	   echo -n "1" > /sys/class/gpio/gpio16/value
		   echo -n "out" > /sys/class/gpio/gpio13/direction
	   echo -n "13" > /sys/class/gpio/unexport
	   echo -n "0" > /sys/class/gpio/gpio34/value
	   echo -n "16" > /sys/class/gpio/unexport
	   echo -n "76" > /sys/class/gpio/unexport
	   echo -n "34" > /sys/class/gpio/unexport
	   echo -n "77" > /sys/class/gpio/unexport
	   ;;
       esac
       ;;
     status)
	   ls -d /sys/class/gpio/gpio*
	   ;;
     *)
	   echo -n "Usage: $0 " 
	   echo "{start|stop|restart|force-reload|status}"
	   exit 1
	   ;;
   esac

   exit 0

   #+END_SRC

   Então utiliza-se as portas *GPIO* correspondentes para ler e escrever
   os sinais digitais, conforme o programa abaixo.

   #+BEGIN_SRC c
   /*
     blink.c: Blinks a LED on Galileog gpio3 or Galileo Gen2 IO13.

     Copyright (c) 2016, 2020 Walter Fetter Lages <w.fetter@ieee.org>

       This program is free software; you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation; either version 2 of the License, or
       (at your option) any later version.

       This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

       You should have received a copy of the GNU General Public License
       along with this program; if not, write to the Free Software
       Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

       You can also obtain a copy of the GNU General Public License
       at <http://www.gnu.org/licenses>.

   */

   #include <fcntl.h>
   #include <string.h>
   #include <unistd.h>
   #include <stdio.h>

   int main(int argc,char *argv[])
   {
	   char state;
	   int led = 0;
	   int button = 0;
	   char s[20];
	   int n;


	   led=open("/sys/devices/virtual/dmi/id/board_name", O_RDONLY);
	   n = read(led, s, sizeof s);
	   close(led);
	   s[n-1] = '\0'; /* Discards new line */

	   if(strncmp(s,"Galileo",sizeof s) == 0)
	       led=open("/sys/class/gpio/gpio3/value", O_WRONLY);
	   else if(strncmp(s,"GalileoGen2",sizeof s) == 0) {
	       led=open("/sys/class/gpio/gpio14/value", O_WRONLY);
		   button=open("/sys/class/gpio/gpio13/value", O_RDONLY);
	   } else return -1;

	   for(;;)
	   {	
		   // Read signal from button
		   lseek(button, 0, SEEK_SET);
		   read(button, &state, sizeof state);

		   // Write state on button
		   lseek(led, 0, SEEK_SET);
		   write(led, &state, sizeof state);
	   }

	   close(led);
	   close(button);

	   return 0;
   }
   #+END_SRC


   E por fim, basta remover a configuração da inicialização da Galileo.
* LAB04 (2020-06-23)
** Chamada de subrotinas da linguagem C

 O objetivo desse laboratório é explorar maneiras de desenvolver
 rotinas em Assembly que possam ser chamadas a partir de programas em
 linguagem C.

 Em linguagens de alto nível, os parâmetros para as funções são
 passados através da pilha do sistema. Cada linguagem possui certas
 convenções de como deve ser feita essa passagem, diferendo em alguns
 pontos como:

 - Ordem com o que os parâmetros são colocados na pilha;
 - Se os parâmetros são passados por valor (o parâmetro é colocado na
   pilha) ou por referência (o end. do parâmetro é colocado na pilha);
 - Se quem limpa a pilha (remove os parâmetros) é a função chamada ou
   a chamadora.

 Em particular, *na linguagem C*, a convenção é que os parâmetros são
 colocados na pilha *por valor*, da direita para a esquerda (ou seja, o
 último parâmetro é o primeiro a ser colocado na pilha) e quem limpa a
 pilha é a função que está *fazendo a chamada*. 

 Usualmente em sistemas *IA32*, o valor de retorno da função deve estar
 no registrador *eax*, se for de *32 bits* ou *edx:eax*, se for de *64 bits*
 (ou *st(0)*), se for de ponto fluante. No *Linux* tem-se ainda que os
 registradores *ebp, esi, edi e ebx*, ou seja, os registradores *de base
 e* *de índice*, devem ser preservados através da chamada da subrotina
 (isto é, devem ser salvos e restaurados, se forem utilziados pela
 subrotina), enquantos os demais podem ser utilizados livremente. 

 Em sistemas *x86_64*, quando executando código de 64 bits, a convenção
 de chamadas de funções é otimizada para passar os parâmetros por
 registrador quando a função possui poucos parâmetros. Os
 registradores *rdi, rsi, rdx, rcx, r8 e r9* são utilizados para passar
 argumentos inteiros e ponteiros, e os registradores *xmm0, xmm1,*
 *xmm2, xmm3, xmm4, xmm5, xmm6, e xmm7* são utilizados para argumentos
 em ponto flutuante. Os demais argumentos são passados pela pilha. O
 valor de retorno da função deve estar em *rax* e os registradores *rbp*
 *e rbx* devem ser preservados.

*** Programas em C chamando rotinas em Assembly

  Programa em C para calcular soma e diferença entre dois inteiros.

  #+BEGIN_SRC c
  /*
    callasm.c: Calls assembly functions for sum and difference.

    Copyright (c) 2016 Walter Fetter Lages <w.fetter@ieee.org>

      This program is free software; you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation; either version 2 of the License, or
      (at your option) any later version.

      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.

      You should have received a copy of the GNU General Public License
      along with this program; if not, write to the Free Software
      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

      You can also obtain a copy of the GNU General Public License
      at <http://www.gnu.org/licenses>.

  */

  #include <stdio.h>
  #include <stdlib.h>

  #include <asmops.h>

  int main(int argc, char *argv[])
  {
	  int a;
	  int b;
	  int s;
	  int d;

	  if(argc != 3)
	  {
		  printf("Usage:\n\t%s <int> <int>\n", argv[0]);
		  return -1;
	  }

	  a=atoi(argv[1]);
	  b=atoi(argv[2]);

	  s=sum(a,b);
	  d=diff(&a,&b);

	  printf("%d+%d=%d\n%d-%d=%d\n",a,b,s,a,b,d);

	  return 0;
  }
  #+END_SRC
 
  Protótipos das funções sum e diff

  #+BEGIN_SRC c
  /*
    asmops.h: Header file for sum and difference in Assembly.

    Copyright (c) 2016 Walter Fetter Lages <w.fetter@ieee.org>

      This program is free software; you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation; either version 2 of the License, or
      (at your option) any later version.

      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.

      You should have received a copy of the GNU General Public License
      along with this program; if not, write to the Free Software
      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

      You can also obtain a copy of the GNU General Public License
      at <http://www.gnu.org/licenses>.

  */

  #ifndef ASMOPS_H
  #define ASMOPS_H

  extern int sum(int a, int b);
  extern int diff(int *a, int *b);

  #endif
  #+END_SRC

  Funções implementadas em assembly

  #+BEGIN_SRC assembly
  /*
    asmops.s: sum and difference in Assembly.

    Copyright (c) 2016 Walter Fetter Lages <w.fetter@ieee.org>

      This program is free software; you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation; either version 2 of the License, or
      (at your option) any later version.

      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.

      You should have received a copy of the GNU General Public License
      along with this program; if not, write to the Free Software
      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

     You can also obtain a copy of the GNU General Public License
      at <http://www.gnu.org/licenses>.
  */

	  .intel_syntax noprefix

	  .text

	  .global	sum
	  .global	diff

  # int sum(int a, int b)
  sum:
	  push	ebp
	  mov	ebp, esp

	  mov	eax, [ebp+8]	# a
	  add	eax, [ebp+12]	# b

	  pop	ebp
	  ret

  # int diff(int &a, int &b)
  diff:
	  push	ebp
	  mov	ebp, esp
	  push	ebx

	  mov	ebx, [ebp+8]	# &a
	  mov	eax, [ebx]	# a
	  mov	ebx, [ebp+12]	# &b
	  sub	eax, [ebx]	# b

	  pop	ebx
	  pop	ebp
	  ret
  #+END_SRC

*** Experimentos
