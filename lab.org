#+Title: Laboratórios de Micro controladores
#+Author: Lucas Valandro da Rocha
#+Email: lucas.valandrorocha@inf.ufrgs.br
#+Language: pt

* LAB01 (2020-06-01 / 2020-06-04)
** Setup do cartão microSD
*** Download da imagem
       
    https://downloadmirror.intel.com/26418/eng/Galileo_Poky_SW_image_20160606.zip

*** Descompactando arquivo no cartão microsd
  *MAC OSX*
    
   diskutil list
    
   -  Ache o seu cartão sd, no meu caso, */dev/disk2*

   - Instale o pacote coreutils através do HomeBrew

   brew install coreutils

   - Execute o seguinte comando

   unzip -p Galileo...zip | sudo gdd of=/dev/disk2 bs=3m conv=fsync status=progress

   - Após a instalação, basta inserir o cartão na Galileo

   OBS.: Caso receba uma mensagem estilo "Resource busy", você deve
   então:

   diskutil unmountDisk force /dev/disk2

*** Boot da Galileo
    
   Após inserir o cartão SD e conectar sua placa no seu roteador,
   então é necessário encontrar sua Galileo na rede local.

   Para encontrar a Galileo na sua rede, você pode utilizar os seguintes comandos:

   - Visualização da tabela ARP e procura do MAC addr da Galileo
      
   arp -a

   - Procura pelo IP na rede

   Instale o pacote ip via HomeBrew

   brew install iproute2mac

   Após instalação, basta:
   
   ip neighbor

*** Configuração de acesso rápido
  
  Após descobrir o IP da galileo em sua rede, é uma boa prática
  configurar acesso via ssh de maneira rápida, para isso:

  - Utilize o comando para gerar (caso não possua) uma chave pública

  ssh-keygen 

  - Copie essa chave para dentro da Galileo com o comando

  scp ~/.ssh/id_rsa.pub root@<galileo-ip>

  - Acesse a Galileo e guarde essa chave no local adequado

  mkdir .ssh
  
  cat id_ras.pub >> .ssh/authorized_keys

  - Feito, basta sair com o comando *exit*

* LAB02 (2020-06-06)
** Configuração do ambiente de desenvolvimento
*** Download do Intel System Studio IoT Edition e configuração

  *Note: A partir daqui o tutorial está sendo executado em uma VM de Linux por questões de incompatibilidade com o MacOS*

  http://www.ece.ufrgs.br/~fetter/eng10032/iss-iot-linux_03-24-16.tar.bz2

  - Descompacte o arquivo no diretorio /opt

  cd /opt

  - Dê permissões aos arquivos descompactados

  chown -R root.root iss-iot-linux

  chmod -R go-w iss-iot-linux

  chmod -R -s iss-iot-linux

  - Ainda no mesmo diretório crie um link para a versão atual do I.S.S
    IoT

  ln -s iss-iot-linux iot-devkit

  - Crie um link para o diretório de ferramentas de desenvolvimento

  cd iot-devkit
  ln -s devkit-x86 1.7.2

  - Alterar o arquivo *iot-devkit/sdk-relocator/relocate_sdk.sh*

  De *find* para *gfind*

  - Execute o comando utilizando o diretório que você instalou o ambiente

  INSTALL_DIR="/Users/valandro/galileo/iot-devkit" sdk-relocator/relocate_sdk.sh

** Experimentos
*** Configurando as variáveis de ambiente 

  export DEVKIT=$HOME/galileo/iot-devkit/devkit-x86

  export PATH=$PATH:$DEVKIT/sysroots/x86_64-pokysdk-linux/usr/bin/i586-poky-linux/

  export CROSS_COMPILE=i586-poky-linux-

  export ARCH=x86

*** Executando o primeiro programa na Galileo

  Crie um diretório para salvar os primeiros arquivos do projeto.

  Makefile

  #+BEGIN_SRC C
  TARGET=hello
  SRCS=$(TARGET).c

  FLAGS=-O2 -Wall -g -MMD
  INCLUDE=-I.
  LIBDIR=
  LIBS=

  CC=$(CROSS_COMPILE)gcc
  CFLAGS=$(FLAGS) $(INCLUDE)
  LDFLAGS=$(LIBDIR) $(LIBS)

  all: $(TARGET)

  $(TARGET): $(SRCS:.c=.o)
		$(CC) -o $@ $^ $(LDFLAGS)

  %.o: %.c
		$(CC) $(CFLAGS) -c -o $@ $<

  -include $(SRCS:.c=.d) 22
  clean:
		rm -f *~ *.bak *.o *.d

  distclean: clean
		rm -f $(TARGET)

  #+END_SRC

  hello.c

  #+BEGIN_SRC C
  #include <stdio.h>
  int main(int argc, char *argv[]) {
    printf("Hello, world!\n");

    return 0;
  }
  #+END_SRC
 

  Basta executar o comando *make*

  Copie o executável para sua galileo através do comando

  scp hello <user>@<ip>:

  Entre na galileo e execute para constatar seu funcionamento.

*** Criando um segundo programa para a Galileo

  A ideia é criar um hello world em C++, fazendo adaptações no
  Makefile existente.

  #+BEGIN_SRC C
  TARGET=hello
  SRCS=$(TARGET).cpp

  FLAGS=-O2 -Wall -g -MMD
  INCLUDE=-I.
  LIBDIR=
  LIBS=

  CPP=$(CROSS_COMPILE)g++
  CFLAGS=$(FLAGS) $(INCLUDE)
  LDFLAGS=$(LIBDIR) $(LIBS)

  all: $(TARGET)

  $(TARGET): $(SRCS:.cpp=.out)
		$(CPP) -o $@ $^ $(LDFLAGS)

  %.out: %.cpp
		$(CPP) $(CFLAGS) -c -o $@ $<

  -include $(SRCS:.cpp=.d) 22

  clean:
		rm -f *~ *.out *.d

  distclean: clean
		rm -f $(TARGET)

  #+END_SRC

  #+BEGIN_SRC CPP
  #include <iostream>

  int main() {
	std::cout << "Hello World!\n";
	return 0;
  }
  #+END_SRC
* LAB03 (2020-06-14 / 2020-06-17)
** Utilizando pinos de I/O
*** Explicação sobre pinos de I/O na Galileo e seu funcionamento

   GPIO: General-purpose input/output


   Cada pino conector de *shield* possui várias funções, e para
   utilizá-los é necessários configurar seus multiplexadores para
   obter o efeito desejado.
 

   Pinos:
   - IO2 e IO3 => Quando configurados como GPIO são comandados
     diretamente pelo Quark X1000.
   - A0 -> A5 => São compartilhados com o conversor A/D, podem ser
     configurados apenas para saída, além de terem capacitores de
     *150nF* em suas saídas.
   - IO0 -> IO6 e IO9-IO13 => Quando configurados como GPIO são
     comandados diretamente pelo Quark X1000, os demais são obtidos
     através de expansores, e por isso possuem *latência maior*.


   Ou seja, algumas portas GPIO estão disponíveis no conector de
   shield e outras são usadas internamente na Galileo para controlar 
   os multiplexadores.

   Para tanto, a *Galileo Gen2* possui 3 expansores de GPIO PCAL9535A
   conectados ao Quark X1000 através do barramento I2C nos endereços
   *0x25, 0x26 e 0x27*.
   
*** Acesso às Portas GPIO

   Para utilizar os pinos de I/O no conector de shield da Galileo Gen2
   é necessário configurar:

   - O(s) multiplexador(es) que conectam o pino no conector ao Quark
     ou ao chip da Galileo que provê a funcionalidade desejada.
   - A direção do buffer associado ao sinal. *(Na Galileo Gen2)*
   - Se um resistor de pull-up ou pull-down de 22k ohm deve ser
     conectado ao pino. *(Gen1 o resistor é de 5.6k ohm)*
   - A direção do sinal.

   *NOTE QUE* na Galileo Gen2 deve-se configurar *independentemente* a
   direção do buffer e a direção do pino de GPIO. Uma tabela com o
   mapeamento de I/O está disponível no Moodle.

*** Configuração dos Pinos do Shield para uso como GPIO

  Na *Galileo Gen2* para configurar o pino *IO13* como saída digital,
  pode-se verificar, através da tabela de mapeamento de pinos de I/O,
  que deve-se configurar os *gpio46* e *gpio30* como saída em *nível*
  *lógico baixo*, enquanto o *gpio31* controla se será usado ou não o
  resistor de pull-up ou pull-down e, finalmente o *gpio7* controla o
  sinal que aparecerá no pino *IO13*.

  Para configurar um determinado *gpio*, é necessário primeiro exportar
  a porta. Isto é feito escrevendo o número (em ASCII) da porta *GPIO*
  em */sys/class/gpio/export*. Por exemplo, usando comandos do shell:

  #+BEGIN_SRC shell

  echo -n "out" > /sys/class/gpio/gpio46/direction

  #+END_SRC

  Com isso surgirá um diretório correspondente à porta. No caso, em
  */sys/class/gpio/gpio46*. A direção da porta é controlada escrevendo
  "in" ou "out" em */sys/class/gpio/gpioXX/direction*.


  #+BEGIN_SRC shell
  
  echo -n "out" > /sys/class/gpio/gpio46/direction
  
  #+END_SRC


  Para escrever ou ler uma porta GPIO, pode-se utilizar os comandos a
  seguir:

  #+BEGIN_SRC shell

  echo -n "0" > /sys/class/gpio/gpio46/value

  ou 

  cat /sys/class/gpio/gpio46/value

  #+END_SRc

  Para as portas que controlam os *multiplexadores* ou direção dos
  buffers também é possível escrever "low" ou "high" no pseudo-arquivo
  *direction*. Isso é equivalente a configurar simultaneamente *direction*
  para "out" e *value* para "0" ou "1".

  Quando a porta I/O *não for mais utilizada* basta "desexportar"
  escrevendo em:


  #+BEGIN_SRC shell

  echo -n "46" > /sys/class/gpio/unexport

  #+END_SRC

*** Ajuste das permissões

  Por default, os arquivos em /sys/class/gpio só podem ser escritos
  pelo superusuário. Isso iria requerer que todos usuários que
  utilizassem o GPIO tivessem permissões de superusuário, o que não é
  uma boa ideia por questões de segurança.

  Uma alternativa para esse problema é criar um grupo chamado *gpio* e
  dar as devidas permissões para os arquivos /sys/class/gpio.

  Criando um novo usuário na Galileo, primeiro acesso como *root*.

  #+BEGIN_SRC shell

  sudo useradd <username>

  sudo passwd <username>

  #+END_SRC

  Obs.: Talvez seja necessário adicionar sua chave pública no folder
  .ssh desse novo usuário.

  O script abaixo demonstra como configurar o pino *IO13* como saída e
  ajusta as permissões para que possa ser controlado por usuários que
  pertençam ao grupo *gpio*. Note que os comentários não são meramente
  informativo, eles são necessários para correta interpretação do
  programa.

  
  #+BEGIN_SRC shell

  #! /bin/sh
  ### BEGIN INIT INFO
  # Provides: eng10032lab03_1
  # Required-Start:
  # Should-Start:
  # Required-Stop:
  # Default-Start: S
  # Default-Stop:
  # Short-Description: Configures GPIO for Lab 03.
  # Description: Configures GPIO for Lab 03.
  ### END INIT INFO

  case "$1" in
   start|restart|force-reload)
    if [ ! -d /sys/class/gpio/gpio46 ] ; then
     echo -n "46" > /sys/class/gpio/export
    fi
    echo -n "out" > /sys/class/gpio/gpio46/direction
    echo -n "0" > /sys/class/gpio/gpio46/value
    if [ ! -d /sys/class/gpio/gpio30 ] ; then
     echo -n "30" > /sys/class/gpio/export
    fi
    echo -n "out" > /sys/class/gpio/gpio30/direction
    echo -n "0" > /sys/class/gpio/gpio30/value
    if [ ! -d /sys/class/gpio/gpio7 ] ; then
     echo -n "7" > /sys/class/gpio/export
    fi
    echo -n "out" > /sys/class/gpio/gpio7/direction
    chgrp gpio /sys/class/gpio/gpio7/value
    chmod g+rw /sys/class/gpio/gpio7/value
    ;;
   stop)
    echo -n "in" > /sys/class/gpio/gpio7/direction
    echo -n "7" > /sys/class/gpio/unexport
    echo -n "1" > /sys/class/gpio/gpio30/value
    echo -n "30" > /sys/class/gpio/unexport
    echo -n "46" > /sys/class/gpio/unexport
    ;;
   status)
    ls -d /sys/class/gpio/gpio*
  #+END_SRC
