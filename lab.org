#+Title: Laboratórios de Micro controladores
#+Author: Lucas Valandro da Rocha
#+Email: lucas.valandrorocha@inf.ufrgs.br
#+Language: pt

* LAB01 (2020-06-01 / 2020-06-04)
** Setup do cartão microSD
*** Download da imagem
       
    https://downloadmirror.intel.com/26418/eng/Galileo_Poky_SW_image_20160606.zip

*** Descompactando arquivo no cartão microsd
  *MAC OSX*
    
   diskutil list
    
   -  Ache o seu cartão sd, no meu caso, */dev/disk2*

   - Instale o pacote coreutils através do HomeBrew

   brew install coreutils

   - Execute o seguinte comando

   unzip -p Galileo...zip | sudo gdd of=/dev/disk2 bs=3m conv=fsync status=progress

   - Após a instalação, basta inserir o cartão na Galileo

   OBS.: Caso receba uma mensagem estilo "Resource busy", você deve
   então:

   diskutil unmountDisk force /dev/disk2

*** Boot da Galileo
    
   Após inserir o cartão SD e conectar sua placa no seu roteador,
   então é necessário encontrar sua Galileo na rede local.

   Para encontrar a Galileo na sua rede, você pode utilizar os seguintes comandos:

   - Visualização da tabela ARP e procura do MAC addr da Galileo
      
   arp -a

   - Procura pelo IP na rede

   Instale o pacote ip via HomeBrew

   brew install iproute2mac

   Após instalação, basta:
   
   ip neighbor

*** Configuração de acesso rápido
  
  Após descobrir o IP da galileo em sua rede, é uma boa prática
  configurar acesso via ssh de maneira rápida, para isso:

  - Utilize o comando para gerar (caso não possua) uma chave pública

  ssh-keygen 

  - Copie essa chave para dentro da Galileo com o comando

  scp ~/.ssh/id_rsa.pub root@<galileo-ip>

  - Acesse a Galileo e guarde essa chave no local adequado

  mkdir .ssh
  
  cat id_ras.pub >> .ssh/authorized_keys

  - Feito, basta sair com o comando *exit*

* LAB02 (2020-06-06)
** Configuração do ambiente de desenvolvimento
*** Download do Intel System Studio IoT Edition e configuração

  *Note: A partir daqui o tutorial está sendo executado em uma VM de Linux por questões de incompatibilidade com o MacOS*

  http://www.ece.ufrgs.br/~fetter/eng10032/iss-iot-linux_03-24-16.tar.bz2

  - Descompacte o arquivo no diretorio /opt

  cd /opt

  - Dê permissões aos arquivos descompactados

  chown -R root.root iss-iot-linux

  chmod -R go-w iss-iot-linux

  chmod -R -s iss-iot-linux

  - Ainda no mesmo diretório crie um link para a versão atual do I.S.S
    IoT

  ln -s iss-iot-linux iot-devkit

  - Crie um link para o diretório de ferramentas de desenvolvimento

  cd iot-devkit
  ln -s devkit-x86 1.7.2

  - Alterar o arquivo *iot-devkit/sdk-relocator/relocate_sdk.sh*

  De *find* para *gfind*

  - Execute o comando utilizando o diretório que você instalou o ambiente

  INSTALL_DIR="/Users/valandro/galileo/iot-devkit" sdk-relocator/relocate_sdk.sh

** Experimentos
*** Configurando as variáveis de ambiente 

  export DEVKIT=$HOME/galileo/iot-devkit/devkit-x86

  export PATH=$PATH:$DEVKIT/sysroots/x86_64-pokysdk-linux/usr/bin/i586-poky-linux/

  export CROSS_COMPILE=i586-poky-linux-

  export ARCH=x86

*** Executando o primeiro programa na Galileo

  Crie um diretório para salvar os primeiros arquivos do projeto.

  Makefile

  #+BEGIN_SRC c
  TARGET=hello
  SRCS=$(TARGET).c

  FLAGS=-O2 -Wall -g -MMD
  INCLUDE=-I.
  LIBDIR=
  LIBS=

  CC=$(CROSS_COMPILE)gcc
  CFLAGS=$(FLAGS) $(INCLUDE)
  LDFLAGS=$(LIBDIR) $(LIBS)

  all: $(TARGET)

  $(TARGET): $(SRCS:.c=.o)
		$(CC) -o $@ $^ $(LDFLAGS)

  %.o: %.c
		$(CC) $(CFLAGS) -c -o $@ $<

  -include $(SRCS:.c=.d) 22
  clean:
		rm -f *~ *.bak *.o *.d

  distclean: clean
		rm -f $(TARGET)

  #+END_SRC

  hello.c

  #+BEGIN_SRC c
  #include <stdio.h>
  int main(int argc, char *argv[]) {
    printf("Hello, world!\n");

    return 0;
  }
  #+END_SRC
 

  Basta executar o comando *make*

  Copie o executável para sua galileo através do comando

  scp hello <user>@<ip>:

  Entre na galileo e execute para constatar seu funcionamento.

*** Criando um segundo programa para a Galileo

  A ideia é criar um hello world em C++, fazendo adaptações no
  Makefile existente.

  #+BEGIN_SRC c
  TARGET=hello
  SRCS=$(TARGET).cpp

  FLAGS=-O2 -Wall -g -MMD
  INCLUDE=-I.
  LIBDIR=
  LIBS=

  CPP=$(CROSS_COMPILE)g++
  CFLAGS=$(FLAGS) $(INCLUDE)
  LDFLAGS=$(LIBDIR) $(LIBS)

  all: $(TARGET)

  $(TARGET): $(SRCS:.cpp=.out)
		$(CPP) -o $@ $^ $(LDFLAGS)

  %.out: %.cpp
		$(CPP) $(CFLAGS) -c -o $@ $<

  -include $(SRCS:.cpp=.d) 22

  clean:
		rm -f *~ *.out *.d

  distclean: clean
		rm -f $(TARGET)

  #+END_SRC
  #+BEGIN_SRC c++
  #include <iostream>

  int main() {
	std::cout << "Hello World!\n";
	return 0;
  }
  #+END_SRC
* LAB03 (2020-06-14 / 2020-06-20)
** Utilizando pinos de I/O
*** Explicação sobre pinos de I/O na Galileo e seu funcionamento

   GPIO: General-purpose input/output


   Cada pino conector de *shield* possui várias funções, e para
   utilizá-los é necessários configurar seus multiplexadores para
   obter o efeito desejado.
 

   Pinos:
   - IO2 e IO3 => Quando configurados como GPIO são comandados
     diretamente pelo Quark X1000.
   - A0 -> A5 => São compartilhados com o conversor A/D, podem ser
     configurados apenas para saída, além de terem capacitores de
     *150nF* em suas saídas.
   - IO0 -> IO6 e IO9-IO13 => Quando configurados como GPIO são
     comandados diretamente pelo Quark X1000, os demais são obtidos
     através de expansores, e por isso possuem *latência maior*.


   Ou seja, algumas portas GPIO estão disponíveis no conector de
   shield e outras são usadas internamente na Galileo para controlar 
   os multiplexadores.

   Para tanto, a *Galileo Gen2* possui 3 expansores de GPIO PCAL9535A
   conectados ao Quark X1000 através do barramento I2C nos endereços
   *0x25, 0x26 e 0x27*.
   
*** Acesso às Portas GPIO

   Para utilizar os pinos de I/O no conector de shield da Galileo Gen2
   é necessário configurar:

   - O(s) multiplexador(es) que conectam o pino no conector ao Quark
     ou ao chip da Galileo que provê a funcionalidade desejada.
   - A direção do buffer associado ao sinal. *(Na Galileo Gen2)*
   - Se um resistor de pull-up ou pull-down de 22k ohm deve ser
     conectado ao pino. *(Gen1 o resistor é de 5.6k ohm)*
   - A direção do sinal.

   *NOTE QUE* na Galileo Gen2 deve-se configurar *independentemente* a
   direção do buffer e a direção do pino de GPIO. Uma tabela com o
   mapeamento de I/O está disponível no Moodle.

*** Configuração dos Pinos do Shield para uso como GPIO

  Na *Galileo Gen2* para configurar o pino *IO13* como saída digital,
  pode-se verificar, através da tabela de mapeamento de pinos de I/O,
  que deve-se configurar os *gpio46* e *gpio30* como saída em *nível*
  *lógico baixo*, enquanto o *gpio31* controla se será usado ou não o
  resistor de pull-up ou pull-down e, finalmente o *gpio7* controla o
  sinal que aparecerá no pino *IO13*.

  Para configurar um determinado *gpio*, é necessário primeiro exportar
  a porta. Isto é feito escrevendo o número (em ASCII) da porta *GPIO*
  em */sys/class/gpio/export*. Por exemplo, usando comandos do shell:

  #+BEGIN_SRC shell

  echo -n "46" > /sys/class/gpio/export

  #+END_SRC

  Com isso surgirá um diretório correspondente à porta. No caso, em
  */sys/class/gpio/gpio46*. A direção da porta é controlada escrevendo
  "in" ou "out" em */sys/class/gpio/gpioXX/direction*.


  #+BEGIN_SRC shell
  
  echo -n "out" > /sys/class/gpio/gpio46/direction
  
  #+END_SRC


  Para escrever ou ler uma porta GPIO, pode-se utilizar os comandos a
  seguir:

  #+BEGIN_SRC shell

  echo -n "0" > /sys/class/gpio/gpio46/value

  ou 

  cat /sys/class/gpio/gpio46/value

  #+END_SRc

  Para as portas que controlam os *multiplexadores* ou direção dos
  buffers também é possível escrever "low" ou "high" no pseudo-arquivo
  *direction*. Isso é equivalente a configurar simultaneamente *direction*
  para "out" e *value* para "0" ou "1".

  Quando a porta I/O *não for mais utilizada* basta "desexportar"
  escrevendo em:


  #+BEGIN_SRC shell

  echo -n "46" > /sys/class/gpio/unexport

  #+END_SRC

*** Ajuste das permissões

  Por default, os arquivos em /sys/class/gpio só podem ser escritos
  pelo superusuário. Isso iria requerer que todos usuários que
  utilizassem o GPIO tivessem permissões de superusuário, o que não é
  uma boa ideia por questões de segurança.

  Uma alternativa para esse problema é criar um grupo chamado *gpio* e
  dar as devidas permissões para os arquivos /sys/class/gpio.

  Criando um novo usuário na Galileo, primeiro acesso como *root*.

  #+BEGIN_SRC shell

  sudo useradd <username>

  sudo passwd <username>

  #+END_SRC

  Obs.: Talvez seja necessário adicionar sua chave pública no folder
  .ssh desse novo usuário.

  O script abaixo demonstra como configurar o pino *IO13* como saída e
  ajusta as permissões para que possa ser controlado por usuários que
  pertençam ao grupo *gpio*. Note que os comentários não são meramente
  informativo, eles são necessários para correta interpretação do
  programa.

  
  #+NAME eng1002lab03_1
  #+BEGIN_SRC shell
  #! /bin/sh
  ### BEGIN INIT INFO
  # Provides:          eng10032lab03_1
  # Required-Start:    
  # Should-Start:      
  # Required-Stop:     
  # Default-Start:     S
  # Default-Stop:
  # Short-Description: Configures GPIO for Lab 03.
  # Description:       Configures GPIO for Lab 03.
  ### END INIT INFO

  boardId=`cat /sys/devices/virtual/dmi/id/board_name`

  case "$1" in
    start|restart|force-reload)
      case $boardId in
	"Galileo")
	  if [ ! -d /sys/class/gpio/gpio55 ] ; then
	      echo -n "55" > /sys/class/gpio/export
	  fi
	  echo -n "out" > /sys/class/gpio/gpio55/direction
	  echo -n "1" > /sys/class/gpio/gpio55/value

	  if [ ! -d /sys/class/gpio/gpio39 ] ; then
	      echo -n "39" > /sys/class/gpio/export
	  fi
	  echo -n "out" > /sys/class/gpio/gpio39/direction
	  echo -n "strong" > /sys/class/gpio/gpio39/drive
	  chgrp gpio /sys/class/gpio/gpio39/value
	  chmod g+rw /sys/class/gpio/gpio39/value

	  # IO13 LED is not mounted. Use the one at gpio3
	  if [ ! -d /sys/class/gpio/gpio3 ] ; then
	      echo -n "3" > /sys/class/gpio/export
	  fi
	  echo -n "out" > /sys/class/gpio/gpio3/direction
	  chgrp gpio /sys/class/gpio/gpio3/value
	  chmod g+rw /sys/class/gpio/gpio3/value
	  ;;
	"GalileoGen2")
	  if [ ! -d /sys/class/gpio/gpio46 ] ; then
	      echo -n "46" > /sys/class/gpio/export
	  fi
	  echo -n "out" > /sys/class/gpio/gpio46/direction
	  echo -n "0" > /sys/class/gpio/gpio46/value

	  if [ ! -d /sys/class/gpio/gpio30 ] ; then
	      echo -n "30" > /sys/class/gpio/export
	  fi
	  echo -n "out" > /sys/class/gpio/gpio30/direction
	  echo -n "0" > /sys/class/gpio/gpio30/value

	  if [ ! -d /sys/class/gpio/gpio7 ] ; then
	      echo -n "7" > /sys/class/gpio/export
	  fi
	  echo -n "out" > /sys/class/gpio/gpio7/direction
	  chgrp gpio /sys/class/gpio/gpio7/value
	  chmod g+rw /sys/class/gpio/gpio7/value
	  ;;
      esac
      ;;
    stop)
      case $boardId in
	"Galileo")
	  echo -n "in" > /sys/class/gpio/gpio39/direction
	  echo -n "39" > /sys/class/gpio/unexport
	  echo -n "55" > /sys/class/gpio/unexport
	  echo -n "3" > /sys/class/gpio/unexport
	  ;;
	"GalileoGen2")
	  echo -n "in" > /sys/class/gpio/gpio7/direction
	  echo -n "7" > /sys/class/gpio/unexport
	  echo -n "1" > /sys/class/gpio/gpio30/value
	  echo -n "30" > /sys/class/gpio/unexport
	  echo -n "46" > /sys/class/gpio/unexport
	  ;;
      esac
      ;;
    status)
	  ls -d /sys/class/gpio/gpio*
	  ;;
    ,*)

	echo -n "Usage: $0 " 
	echo "{start|stop|restart|force-reload|status}"
	exit 1
	;;
     esac
  exit 0
  #+END_SRC
** Experimentos
*** Configuração da Galileo para Usar GPIO
   
   O primeiro copie para Galileo o script *eng10032lab03_1*

   #+BEGIN_SRC shell

   scp eng10032lab03_1 <username>@<ip>:  
 
   #+END_SRC

   Agora, acesse a Galileo como *superusuário* e adicione seu usuário no grupo *gpio*
   
   #+BEGIN_SRC shell

   groupadd -r gpio

   groupmems -g gpio -a <username>

   #+END_SRC

   Copie o arquivo para o diretório /etc/init.d na galileo com o
   comando:

   #+BEGIN_SRC shell
   
   cp ~/eng10032lab03_1 /etc/init.d   

   #+END_SRC

   Torne o *script* executável com o comando:

   #+BEGIN_SRC shell

   chmod +x /etc/init.d/en10032lab03_1

   #+END_SRC


   Configure o linux para executar o script durante a inicialização

   #+BEGIN_SRC shell

   update-rc.d eng10032lab031_1 defaults

   #+END_SRC

   E por fim, reinicialize a Galileo

   #+BEGIN_SRC shell

   reboot

   #+END_SRC
*** Uso dos pinos de GPIO
  
   Na Galileo Gen2 o pino *IO13* (onde está conectado o LED) é controlado
   pela porta *gpio7*, que é roteada para esse pino colocando a *gpio46* em
   nível lógico baixo. A *gpio30* controla a direção do buffer associado
   (nível lógico *baixo* para saída e *alto* para entrada). Neste caso, é
   irrelevante o estado do resistor de /pull-up/ ou /pull-down/ controlado
   pelo *gpio31*.

   Antes de realizar criar os programas, é necessário configurar
   um script que será executado no momento da inicialização da
   Galileo. Esse script servirá para configuração dos pinos de *GPIO* que
   serão utilizados pelo seu programa. *É necessário excluir essa*
   *configuração assim que terminar de executar seus programas, para que*
   *as portas estejam acessíveis futuramente.*

   Para adicionar esses scripts, entre como super usuário na Galileo e:

   #+BEGIN_SRC shell

   cp script /etc/init.d
   chmod +x /etc/init.d/script
   update-rc.d script defaults

   #+END_SRC


   E para excluir esse script da inicialização basta:

   #+BEGIN_SRC shell

   update-rc.d -f script remove

   #+END_SRC

**** Piscando o LED do pino IO13

    Primeiro, configure o arquivo /eng10032lab03_1/ na Galileo

    #+BEGIN_SRC shell
    #! /bin/sh
    ### BEGIN INIT INFO
    # Provides:          eng10032lab03_1
    # Required-Start:    
    # Should-Start:      
    # Required-Stop:     
    # Default-Start:     S
    # Default-Stop:
    # Short-Description: Configures GPIO for Lab 03.
    # Description:       Configures GPIO for Lab 03.
    ### END INIT INFO

    boardId=`cat /sys/devices/virtual/dmi/id/board_name`

    case "$1" in
      start|restart|force-reload)
	case $boardId in
	  "Galileo")
	    if [ ! -d /sys/class/gpio/gpio55 ] ; then
		echo -n "55" > /sys/class/gpio/export
	    fi
	    echo -n "out" > /sys/class/gpio/gpio55/direction
	    echo -n "1" > /sys/class/gpio/gpio55/value

	    if [ ! -d /sys/class/gpio/gpio39 ] ; then
		echo -n "39" > /sys/class/gpio/export
	    fi
	    echo -n "out" > /sys/class/gpio/gpio39/direction
	    echo -n "strong" > /sys/class/gpio/gpio39/drive
	    chgrp gpio /sys/class/gpio/gpio39/value
	    chmod g+rw /sys/class/gpio/gpio39/value

	    # IO13 LED is not mounted. Use the one at gpio3
	    if [ ! -d /sys/class/gpio/gpio3 ] ; then
		echo -n "3" > /sys/class/gpio/export
	    fi
	    echo -n "out" > /sys/class/gpio/gpio3/direction
	    chgrp gpio /sys/class/gpio/gpio3/value
	    chmod g+rw /sys/class/gpio/gpio3/value
	    ;;
	  "GalileoGen2")
	    if [ ! -d /sys/class/gpio/gpio46 ] ; then
		echo -n "46" > /sys/class/gpio/export
	    fi
	    echo -n "out" > /sys/class/gpio/gpio46/direction
	    echo -n "0" > /sys/class/gpio/gpio46/value

	    if [ ! -d /sys/class/gpio/gpio30 ] ; then
		echo -n "30" > /sys/class/gpio/export
	    fi
	    echo -n "out" > /sys/class/gpio/gpio30/direction
	    echo -n "0" > /sys/class/gpio/gpio30/value

	    if [ ! -d /sys/class/gpio/gpio7 ] ; then
		echo -n "7" > /sys/class/gpio/export
	    fi
	    echo -n "out" > /sys/class/gpio/gpio7/direction
	    chgrp gpio /sys/class/gpio/gpio7/value
	    chmod g+rw /sys/class/gpio/gpio7/value
	    ;;
	esac
	;;
      stop)
	case $boardId in
	  "Galileo")
	    echo -n "in" > /sys/class/gpio/gpio39/direction
	    echo -n "39" > /sys/class/gpio/unexport
	    echo -n "55" > /sys/class/gpio/unexport
	    echo -n "3" > /sys/class/gpio/unexport
	    ;;
	  "GalileoGen2")
	    echo -n "in" > /sys/class/gpio/gpio7/direction
	    echo -n "7" > /sys/class/gpio/unexport
	    echo -n "1" > /sys/class/gpio/gpio30/value
	    echo -n "30" > /sys/class/gpio/unexport
	    echo -n "46" > /sys/class/gpio/unexport
	    ;;
	esac
	;;
      status)
	    ls -d /sys/class/gpio/gpio*
	    ;;
      *)
	    echo -n "Usage: $0 " 
	    echo "{start|stop|restart|force-reload|status}"
	    exit 1
	    ;;
    esac

    exit 0
    #+END_SRC

    Após isso e realizar o /reboot/ dela, ative o cross compiler através
    do script de configuração e então compile o seguinte código.

    #+BEGIN_SRC c
    /*
      blink.c: Blinks a LED on Galileog gpio3 or Galileo Gen2 IO13.

      Copyright (c) 2016, 2020 Walter Fetter Lages <w.fetter@ieee.org>

	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; either version 2 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

	You can also obtain a copy of the GNU General Public License
	at <http://www.gnu.org/licenses>.

    */

    #include <fcntl.h>
    #include <string.h>
    #include <unistd.h>

    int main(int argc,char *argv[])
    {
	    char state='0';
	    int fd;
	    char s[20];
	    int n;

	    fd=open("/sys/devices/virtual/dmi/id/board_name",O_RDONLY);
	    n=read(fd,s,sizeof s);
	    close(fd);
	    s[n-1]='\0'; /* Discards new line */

	    if(strncmp(s,"Galileo",sizeof s) == 0)
		fd=open("/sys/class/gpio/gpio3/value",O_WRONLY);
	    else if(strncmp(s,"GalileoGen2",sizeof s) == 0)
		fd=open("/sys/class/gpio/gpio7/value",O_WRONLY);
	    else return -1;

	    for(;;)
	    {	
		    lseek(fd,0,SEEK_SET);
		    write(fd,&state,sizeof state);
		    sleep(1);
		    state^='0'^'1';
	    }

	    close(fd);

	    return 0;
    }
    #+END_SRC 

    Esse trecho de código fará a luz de LED mais próxima do conector
    microusb piscar em intervalos de *1 segundo*.

**** Piscando o LED do pino IO3

   Alterar os pinos, colocar script de inicialização na Galileo

   A ideia de configurar o pino de *IO3* era de criarmos um circuito com
   um push button que iria desabilitar o LED assim que fosse
   apertado. Para isso, foi necessário olhar o mapeamento das portas
   da *Galileo Gen2* e configurar um novo script de inicialização das
   portas, conforme nossa necessidade de utilizarmos a porta *IO3* como
   output para ligar o LED e a porta *IO2* como input do clique do
   botão.

   #+BEGIN_SRC shell

   #! /bin/sh
   ### BEGIN INIT INFO
   # Provides:          eng10032lab03_1
   # Required-Start:    
   # Should-Start:      
   # Required-Stop:     
   # Default-Start:     S
   # Default-Stop:
   # Short-Description: Configures GPIO for Lab 03.
   # Description:       Configures GPIO for Lab 03.
   ### END INIT INFO

   boardId=`cat /sys/devices/virtual/dmi/id/board_name`

   case "$1" in
     start|restart|force-reload)
       case $boardId in
	 "Galileo")
	   if [ ! -d /sys/class/gpio/gpio55 ] ; then
	       echo -n "55" > /sys/class/gpio/export
	   fi
	   echo -n "out" > /sys/class/gpio/gpio55/direction
	   echo -n "1" > /sys/class/gpio/gpio55/value

	   if [ ! -d /sys/class/gpio/gpio39 ] ; then
	       echo -n "39" > /sys/class/gpio/export
	   fi
	   echo -n "out" > /sys/class/gpio/gpio39/direction
	   echo -n "strong" > /sys/class/gpio/gpio39/drive
	   chgrp gpio /sys/class/gpio/gpio39/value
	   chmod g+rw /sys/class/gpio/gpio39/value

	   # IO13 LED is not mounted. Use the one at gpio3
	   if [ ! -d /sys/class/gpio/gpio3 ] ; then
	       echo -n "3" > /sys/class/gpio/export
	   fi
	   echo -n "out" > /sys/class/gpio/gpio3/direction
	   chgrp gpio /sys/class/gpio/gpio3/value
	   chmod g+rw /sys/class/gpio/gpio3/value
	   ;;
	 "GalileoGen2")
	   if [ ! -d /sys/class/gpio/gpio76 ] ; then
	       echo -n "76" > /sys/class/gpio/export
	   fi
	   echo -n "out" > /sys/class/gpio/gpio76/direction
	   echo -n "0" > /sys/class/gpio/gpio76/value

	   if [ ! -d /sys/class/gpio/gpio16 ] ; then
	       echo -n "16" > /sys/class/gpio/export
	   fi
	   echo -n "out" > /sys/class/gpio/gpio16/direction
	   echo -n "0" > /sys/class/gpio/gpio16/value

	   if [ ! -d /sys/class/gpio/gpio14 ] ; then
	       echo -n "14" > /sys/class/gpio/export
	   fi
	   echo -n "out" > /sys/class/gpio/gpio14/direction
	   chgrp gpio /sys/class/gpio/gpio14/value
	   chmod g+rw /sys/class/gpio/gpio14/value

	   # IO2 LED input
	   if [ !d /sys/class/gpio/gpio77 ] ; then
		   echo -n "77" > /sys/class/gpio/export
	   fi
	   echo -n "in" > /sys/class/gpio/gpio77/direction
	   echo -n "1" > /sys/class/gpio/gpio77/value

	   if [ !d /sys/class/gpio/gpio34 ] ; then
		   echo -n "34" > /sys/class/gpio/export
	   fi
	   echo -n "in" > /sys/class/gpio/gpio34/direction
	   echo -n "1" > /sys/class/gpio/gpio34/value

	   if [ ! -d /sys/class/gpio/gpio13 ] ; then
	       echo -n "13" > /sys/class/gpio/export
	   fi
	   echo -n "in" > /sys/class/gpio/gpio13/direction
	   chgrp gpio /sys/class/gpio/gpio13/value
	   chmod g+rw /sys/class/gpio/gpio13/value
	   ;;
       esac
       ;;
     stop)
       case $boardId in
	 "Galileo")
	   echo -n "in" > /sys/class/gpio/gpio39/direction
	   echo -n "39" > /sys/class/gpio/unexport
	   echo -n "55" > /sys/class/gpio/unexport
	   echo -n "3" > /sys/class/gpio/unexport
	   ;;
	 "GalileoGen2")
	   echo -n "in" > /sys/class/gpio/gpio14/direction
	   echo -n "14" > /sys/class/gpio/unexport
	   echo -n "1" > /sys/class/gpio/gpio16/value
		   echo -n "out" > /sys/class/gpio/gpio13/direction
	   echo -n "13" > /sys/class/gpio/unexport
	   echo -n "0" > /sys/class/gpio/gpio34/value
	   echo -n "16" > /sys/class/gpio/unexport
	   echo -n "76" > /sys/class/gpio/unexport
	   echo -n "34" > /sys/class/gpio/unexport
	   echo -n "77" > /sys/class/gpio/unexport
	   ;;
       esac
       ;;
     status)
	   ls -d /sys/class/gpio/gpio*
	   ;;
     *)
	   echo -n "Usage: $0 " 
	   echo "{start|stop|restart|force-reload|status}"
	   exit 1
	   ;;
   esac

   exit 0

   #+END_SRC

   Então utiliza-se as portas *GPIO* correspondentes para ler e escrever
   os sinais digitais, conforme o programa abaixo.

   #+BEGIN_SRC c
   /*
     blink.c: Blinks a LED on Galileog gpio3 or Galileo Gen2 IO13.

     Copyright (c) 2016, 2020 Walter Fetter Lages <w.fetter@ieee.org>

       This program is free software; you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation; either version 2 of the License, or
       (at your option) any later version.

       This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

       You should have received a copy of the GNU General Public License
       along with this program; if not, write to the Free Software
       Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

       You can also obtain a copy of the GNU General Public License
       at <http://www.gnu.org/licenses>.

   */

   #include <fcntl.h>
   #include <string.h>
   #include <unistd.h>
   #include <stdio.h>

   int main(int argc,char *argv[])
   {
	   char state;
	   int led = 0;
	   int button = 0;
	   char s[20];
	   int n;


	   led=open("/sys/devices/virtual/dmi/id/board_name", O_RDONLY);
	   n = read(led, s, sizeof s);
	   close(led);
	   s[n-1] = '\0'; /* Discards new line */

	   if(strncmp(s,"Galileo",sizeof s) == 0)
	       led=open("/sys/class/gpio/gpio3/value", O_WRONLY);
	   else if(strncmp(s,"GalileoGen2",sizeof s) == 0) {
	       led=open("/sys/class/gpio/gpio14/value", O_WRONLY);
		   button=open("/sys/class/gpio/gpio13/value", O_RDONLY);
	   } else return -1;

	   for(;;)
	   {	
		   // Read signal from button
		   lseek(button, 0, SEEK_SET);
		   read(button, &state, sizeof state);

		   // Write state on button
		   lseek(led, 0, SEEK_SET);
		   write(led, &state, sizeof state);
	   }

	   close(led);
	   close(button);

	   return 0;
   }
   #+END_SRC


   E por fim, basta remover a configuração da inicialização da Galileo.
* LAB04 (2020-06-23 / 2020-07-07)
** Chamada de subrotinas da linguagem C

 O objetivo desse laboratório é explorar maneiras de desenvolver
 rotinas em Assembly que possam ser chamadas a partir de programas em
 linguagem C.

 Em linguagens de alto nível, os parâmetros para as funções são
 passados através da pilha do sistema. Cada linguagem possui certas
 convenções de como deve ser feita essa passagem, diferendo em alguns
 pontos como:

 - Ordem com o que os parâmetros são colocados na pilha;
 - Se os parâmetros são passados por valor (o parâmetro é colocado na
   pilha) ou por referência (o end. do parâmetro é colocado na pilha);
 - Se quem limpa a pilha (remove os parâmetros) é a função chamada ou
   a chamadora.

 Em particular, *na linguagem C*, a convenção é que os parâmetros são
 colocados na pilha *por valor*, da direita para a esquerda (ou seja, o
 último parâmetro é o primeiro a ser colocado na pilha) e quem limpa a
 pilha é a função que está *fazendo a chamada*. 

 Usualmente em sistemas *IA32*, o valor de retorno da função deve estar
 no registrador *eax*, se for de *32 bits* ou *edx:eax*, se for de *64 bits*
 (ou *st(0)*), se for de ponto fluante. No *Linux* tem-se ainda que os
 registradores *ebp, esi, edi e ebx*, ou seja, os registradores *de base
   e* *de índice*, devem ser preservados através da chamada da subrotina
   (isto é, devem ser salvos e restaurados, se forem utilziados pela
   subrotina), enquantos os demais podem ser utilizados livremente. 

   Em sistemas *x86_64*, quando executando código de 64 bits, a convenção
   de chamadas de funções é otimizada para passar os parâmetros por
   registrador quando a função possui poucos parâmetros. Os
   registradores *rdi, rsi, rdx, rcx, r8 e r9* são utilizados para passar
   argumentos inteiros e ponteiros, e os registradores *xmm0, xmm1,*
   *xmm2, xmm3, xmm4, xmm5, xmm6, e xmm7* são utilizados para argumentos
   em ponto flutuante. Os demais argumentos são passados pela pilha. O
   valor de retorno da função deve estar em *rax* e os registradores *rbp*
   *e rbx* devem ser preservados.

*** Programas em C chamando rotinas em Assembly

   Programa em C para calcular soma e diferença entre dois inteiros.

   #+BEGIN_SRC c
   /*
     callasm.c: Calls assembly functions for sum and difference.

     Copyright (c) 2016 Walter Fetter Lages <w.fetter@ieee.org>

       This program is free software; you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation; either version 2 of the License, or
       (at your option) any later version.

       This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

       You should have received a copy of the GNU General Public License
       along with this program; if not, write to the Free Software
       Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

       You can also obtain a copy of the GNU General Public License
       at <http://www.gnu.org/licenses>.

   */

   #include <stdio.h>
   #include <stdlib.h>

   #include <asmops.h>

   int main(int argc, char *argv[])
   {
	   int a;
	   int b;
	   int s;
	   int d;

	   if(argc != 3)
	   {
		   printf("Usage:\n\t%s <int> <int>\n", argv[0]);
		   return -1;
	   }

	   a=atoi(argv[1]);
	   b=atoi(argv[2]);

	   s=sum(a,b);
	   d=diff(&a,&b);

	   printf("%d+%d=%d\n%d-%d=%d\n",a,b,s,a,b,d);

	   return 0;
   }
   #+END_SRC

   Protótipos das funções sum e diff

   #+BEGIN_SRC c
   /*
     asmops.h: Header file for sum and difference in Assembly.

     Copyright (c) 2016 Walter Fetter Lages <w.fetter@ieee.org>

       This program is free software; you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation; either version 2 of the License, or
       (at your option) any later version.

       This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

       You should have received a copy of the GNU General Public License
       along with this program; if not, write to the Free Software
       Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

       You can also obtain a copy of the GNU General Public License
       at <http://www.gnu.org/licenses>.

   */

   #ifndef ASMOPS_H
   #define ASMOPS_H

   extern int sum(int a, int b);
   extern int diff(int *a, int *b);

   #endif
   #+END_SRC

   Funções implementadas em assembly

   #+BEGIN_SRC assembly
   /*
     asmops.s: sum and difference in Assembly.

     Copyright (c) 2016 Walter Fetter Lages <w.fetter@ieee.org>

       This program is free software; you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation; either version 2 of the License, or
       (at your option) any later version.

       This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

       You should have received a copy of the GNU General Public License
       along with this program; if not, write to the Free Software
       Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

      You can also obtain a copy of the GNU General Public License
       at <http://www.gnu.org/licenses>.
   */

	   .intel_syntax noprefix

	   .text

	   .global	sum
	   .global	diff

   # int sum(int a, int b)
   sum:
	   push	ebp
	   mov	ebp, esp

	   mov	eax, [ebp+8]	# a
	   add	eax, [ebp+12]	# b

	   pop	ebp
	   ret

   # int diff(int &a, int &b)
   diff:
	   push	ebp
	   mov	ebp, esp
	   push	ebx

	   mov	ebx, [ebp+8]	# &a
	   mov	eax, [ebx]	# a
	   mov	ebx, [ebp+12]	# &b
	   sub	eax, [ebx]	# b

	   pop	ebx
	   pop	ebp
	   ret
   #+END_SRC

*** Experimentos
**** Exercício 1

    Deve-se compilar os programas na Galileo e carregar o executável na
    mesma.

    Ápos isso, então vamos executar o gdbserver na Galileo para fazermos
    a depuração.

    #+BEGIN_SRC shell
    gdbserver <vm ip>:<port> callasm 1 2
    #+END_SRC

    E então, no cliente, deve-se executar o /front end/ para depuração.

    #+BEGIN_SRC shell
    kdbg -r <ip galileo>:<same port> callasm
    #+END_SRC

**** Exercício 2

   O objetivo desse exercício é criar um programa em Assembly para
   conversão de uma string para caracteres em maísculo e impressão
   dessa nova string na tela.

   #+BEGIN_SRC c
   #include <stdio.h>
   #include <stdlib.h>
   #include <touppercase.h>

   int main(int argc,char *argv[])
   {	
	   if(argc != 2)
	   {
		   printf("Usage:\n\t%s <string>\n",argv[0]);
		   return -1;
	   }

	   printf("input: %s\n", argv[1]);
	   to_uppercase(argv[1]);

	   printf("\n");

	   return 0;
   }
   #+END_SRC

   Biblioteca touppercase.h

   #+BEGIN_SRC c
   #ifndef TOUPPERCASE_H
   #define TOUPPERCASE_H

   extern void to_uppercase(char* word);

   #endif
   #+END_SRC

   Arquivo .s com a função para conversão e impressão na tela

   #+BEGIN_SRC asm
	   .intel_syntax noprefix

	   .text

	   .global	to_uppercase

   #
   # void to_uppercase(char* word)
   # function to convert a word to uppercase and print them 
   #

   to_uppercase:
   _start:
	   push	ebp # save stack position so we can restore it later
	   mov	ebp, esp # put stack pointer at base pointer
     mov esi, [ebp + 8] # pointer to the first char of string to auxiliar register (ESI)
     mov edx, 0 # edx it's the string length counter

   to_upper:
     mov al, [esi] # esi it's the pointer to the first char
     cmp al, 0x0 # end of string
     je print
     add edx, 1 # increment the string length
     cmp al, 'a' # if char below 'a' then do nothing
     jb next_char
     cmp al, 'z' # if char greater then 'z' then do nothing
     ja next_char
     sub al, 0x20 # Then convert to upper case ASCII value (subtract 0010 0000)
     mov [esi], al # write it back to esi

   next_char:
     inc esi # go to next char (*esi++)
     jmp to_upper

   print:
     mov ecx, [ebp + 8] # word to be writed
     mov eax, 4 # linux kernel function code for writing function
     mov ebx, 1 # file descriptor, 1 means stdout
     int 0x80 # call write function in the linux kernel
	   pop	ebp  # Reset all registers used by the function
	   ret

   #+END_SRC

* LAB05 (2020-07-05)
** Funcionamento de interrupções e seu processamento no espaço do usuário
 
 Na maioria dos pinos I/O da *Galileo Gen2* podem gerar interrupções. As
 interrupções podem ser geradas nas bordas de subida, descida ou em
 ambas (do sinal). Para que um pino seja usado como fonte de
 interrupção ele deve ser exportado e configurado *como entrada* através
 do diretório /sys/class/gpio.

*** Biblioteca para acessar o sysfs

  Será construída ao longo do curso a biblioteca *galileo2io.h*, os
  arquivos da mesma podem ser encontrados no reposiório do git.

*** Habilitação da interrupção

  As interrupções são configuradas através do arquivo
  /sys/class/gpio/gpioXX/edge, onde XX é o número do GPIO associado ao
  pino no shield da Galileo.

  As seguintes /strings/ devem ser escritas para configurar a
  interrupção:

  - *rising*: Interrupção ativa na borda de subida do sinal
  - *falling*: Interrupção ativa na borda de descida do sinal
  - *both*
  - *none*

*** Experimentos
**** Capturando uma interrupção

   - Para capturar uma interrupção na Galileo deve-se configurar
     corretamente os GPIOs associados, portanto, o primeiro passo é
     configurar e inicializar o arquivo de inicialização da Galileo

   #+NAME eng10032lab05_1
   #+BEGIN_SRC shell
   #! /bin/sh
   ### BEGIN INIT INFO
   # Provides:          eng10032lab05_1
   # Required-Start:    
   # Should-Start:      
   # Required-Stop:     
   # Default-Start:     S
   # Default-Stop:
   # Short-Description: Configures GPIO for Lab 05.
   # Description:       Configures GPIO for Lab 05.
   ### END INIT INFO

   boardId=`cat /sys/devices/virtual/dmi/id/board_name`

   case "$1" in
     start|restart|force-reload)
       case $boardId in
	 "Galileo")
	   if [ ! -d /sys/class/gpio/gpio15 ] ; then
	       echo -n "15" > /sys/class/gpio/export
	   fi
	   echo -n "in" > /sys/class/gpio/gpio15/direction
	   echo -n "0" > /sys/class/gpio/gpio15/value

	   chgrp gpio /sys/class/gpio/gpio15/value
	   chmod g+r /sys/class/gpio/gpio15/value
	   chgrp gpio /sys/class/gpio/gpio15/edge
	   chmod g+rw /sys/class/gpio/gpio15/edge

   # gpio30 = 0 => IO3=SoC	
	   if [ ! -d /sys/class/gpio/gpio30 ] ; then
	       echo -n "30" > /sys/class/gpio/export
	   fi
	   echo -n "out" > /sys/class/gpio/gpio30/direction
	   echo -n "0" > /sys/class/gpio/gpio30/value

	   ;;
	 "GalileoGen2")
	   if [ ! -d /sys/class/gpio/gpio6 ] ; then
	       echo -n "6" > /sys/class/gpio/export
	   fi
	   echo -n "in" > /sys/class/gpio/gpio6/direction
	   echo -n "0" > /sys/class/gpio/gpio6/value

	   chgrp gpio /sys/class/gpio/gpio6/value
	   chmod g+r /sys/class/gpio/gpio6/value
	   chgrp gpio /sys/class/gpio/gpio6/edge
	   chmod g+rw /sys/class/gpio/gpio6/edge

	   # gpio36 = 1 => IO4=in	
	   if [ ! -d /sys/class/gpio/gpio36 ] ; then
	       echo -n "36" > /sys/class/gpio/export
	   fi
	   echo -n "out" > /sys/class/gpio/gpio36/direction
	   echo -n "1" > /sys/class/gpio/gpio36/value

	   # gpio37 = 0 => pull-down
	   if [ ! -d /sys/class/gpio/gpio37 ] ; then
	       echo -n "37" > /sys/class/gpio/export
	   fi
	   echo -n "out" > /sys/class/gpio/gpio37/direction
	   echo -n "0" > /sys/class/gpio/gpio37/value
	   ;;
       esac
       ;;
     stop)
       case $boardId in
	 "Galileo")
	   echo -n "1" > /sys/class/gpio/gpio30/value
	   echo -n "30" > /sys/class/gpio/unexport
	   echo -n "15" > /sys/class/gpio/unexport
	   ;;
	 "GalileoGen2")
	   echo -n "in" > /sys/class/gpio/gpio37/direction
	   echo -n "37" > /sys/class/gpio/unexport
	   echo -n "36" > /sys/class/gpio/unexport
	   echo -n "6" > /sys/class/gpio/unexport
	   ;;
       esac
       ;;
     status)
	   ls -d /sys/class/gpio/gpio*
	   ;;
     *)
	   echo -n "Usage: $0 " 
	   echo "{start|stop|restart|force-reload|status}"
	   exit 1
	   ;;
   esac

   exit 0
   #+END_SRC

   - Após isso, pode-se capturar as interrupções utilizando a
     biblioteca *poll.h*

   #+NAME inttst.c
   #+BEGIN_SRC C
   /*
     inttst.c: Receives an interrupt on Galileo Gen2 IO4.

     Copyright (c) 2016, 2020 Walter Fetter Lages <w.fetter@ieee.org>

       This program is free software; you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation; either version 2 of the License, or
       (at your option) any later version.

       This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

       You should have received a copy of the GNU General Public License
       along with this program; if not, write to the Free Software
       Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

       You can also obtain a copy of the GNU General Public License
       at <http://www.gnu.org/licenses>.

   */

   #include <fcntl.h>
   #include <poll.h>
   #include <stdio.h>
   #include <unistd.h>

   #include <galileo2io.h>

   int main(int argc,char * argv[])
   {
	   unsigned char c;
	   struct pollfd pfd;
	   int board;

	   board=board_name();

	   if(board == BOARD_GALILEO_GEN1)
	       pfd.fd=open("/sys/class/gpio/gpio15/value",O_RDONLY);
	   else if(board == BOARD_GALILEO_GEN2)
	       pfd.fd=open("/sys/class/gpio/gpio6/value",O_RDONLY);
	   else pfd.fd=-1;

	   if(pfd.fd < 0)
	   {
		   perror("Opening gpio:");
		   return -1;
	   }

	   /* Clear old values */
	   read(pfd.fd,&c,1);

	   pfd.events=POLLPRI;

	   puts("Waiting for interrupt...");

	   if(board == BOARD_GALILEO_GEN1)
	       pputs("/sys/class/gpio/gpio15/edge","rising");
	   else if(board == BOARD_GALILEO_GEN2)
	       pputs("/sys/class/gpio/gpio6/edge","both");

	   poll(&pfd,1,-1);

	   lseek(pfd.fd,0,SEEK_SET);
	   read(pfd.fd,&c,1);

	   if(board == BOARD_GALILEO_GEN1)
	       pputs("/sys/class/gpio/gpio15/edge","none");
	   else if(board == BOARD_GALILEO_GEN2)
	       pputs("/sys/class/gpio/gpio6/edge","none");

	   close(pfd.fd);
	   return 0;
   }
   #+END_SRC

**** Contando o número de interrupções

   Através de uma pequena alteração no programa anterior, podemos
   contar o número de vezes que uma interrupção foi capturada, também
   vale ressaltar que o momento de captura é configurado através do
   arquivo *edge* de determinado GPIO.

   #+NAME countint.c
   #+BEGIN_SRC c
   /*
     countint.c: Count the number of interrupts on Galileo Gen2 IO4.

     Copyright (c) 2016, 2020 Walter Fetter Lages <w.fetter@ieee.org>

       This program is free software; you can redistribute it and/or modify
       it under the terms of the GNU General Public License as published by
       the Free Software Foundation; either version 2 of the License, or
       (at your option) any later version.

       This program is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.

       You should have received a copy of the GNU General Public License
       along with this program; if not, write to the Free Software
       Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

       You can also obtain a copy of the GNU General Public License
       at <http://www.gnu.org/licenses>.

   */

   #include <fcntl.h>
   #include <poll.h>
   #include <stdio.h>
   #include <unistd.h>

   #include <galileo2io.h>

   int main(int argc,char * argv[])
   {
	   unsigned char c;
	   struct pollfd pfd;
	   int board;
	   int number_of_int = 0;

	   while(1) {

	   board=board_name();

	   if(board == BOARD_GALILEO_GEN1)
	       pfd.fd=open("/sys/class/gpio/gpio15/value",O_RDONLY);
	   else if(board == BOARD_GALILEO_GEN2)
	       pfd.fd=open("/sys/class/gpio/gpio6/value",O_RDONLY);
	   else pfd.fd=-1;

	   if(pfd.fd < 0)
	   {
		   perror("Opening gpio:");
		   return -1;
	   }

	   read(pfd.fd,&c,1);

	   pfd.events=POLLPRI;

	   puts("Waiting for interrupt...");

	   if(board == BOARD_GALILEO_GEN1)
	       pputs("/sys/class/gpio/gpio15/edge","rising");
	   else if(board == BOARD_GALILEO_GEN2)
	       pputs("/sys/class/gpio/gpio6/edge","rising");

	   poll(&pfd,1,-1);

	   lseek(pfd.fd,0,SEEK_SET);
	   read(pfd.fd,&c,1);

	   number_of_int++;
	   printf("Number of interrupts: %d\n", number_of_int);

	   if(board == BOARD_GALILEO_GEN1)
	       pputs("/sys/class/gpio/gpio15/edge","none");
	   else if(board == BOARD_GALILEO_GEN2)
	       pputs("/sys/class/gpio/gpio6/edge","none");

	   close(pfd.fd);

	   }
	   return 0;
   }
   #+END_SRC
* LAB06 (2020-07-12 / 2020-07-16)
** Funcionamento das saídas PWM da Galileo

 - Esse laboratório tem como objetivo aprendermos como utilizar um
   sinal PWM para simular um sinal analógico e como utilizá-lo para
   comandar o chaveamento de uma etapa de potência, de forma a poder
   variar a tensão média sobre uma carga.

*** Modulação
  
  A modulação é a operação de utilizar um sinal modulante para alterar
  o sinal portador, podendo mudar sua fase, amplitude e/ou
  frequência. Em particular, na modulação por largura de pulso (/PWM/) a
  portadora é um sinal digital de frequência constante e o sinal
  modulante é um sinal analógico. O ciclo de trabalho (*percentual de*
  *tempo que sinal fica em nível lógico alto*) da portadora é variado em
  função da amplitude do sinal modulante.

  Outra característica importante do sinal de PWM é que *seu valor
  médio* *é proporcional à amplitude do sinal modulante*, e portanto, o
  sinal modulante pode ser recuperado utilizando apenas um filtro
  passa-baixas. Isso é particularmente interessante para o acionamento
  de dispositivos de potência, pois, tipicamente, a dinâmica do
  próprio dispositivo já atua como filtro passa-baixas.

  Note que apesar do sinal /PWM/ ser um sinal digital, o ciclo de
  trabalho continua sendo uma *grandeza analógica*; portanto, um sinal
  /PWM/ pode representar um sinal analógico com precisão infinita. Note
  que, dependendo de como o sinal /PWM/ é gerado, *principalmente quando*
  *o modulador é totalmente digital*, essa precisão pode ser limitada
  devido à quantização.

  Na *Galileo Gen2* os sinais /PWM/ são gerados pelo chip PCA9685 da NXP,
  que possui *16 canais de PWM com 12 bits de resolução.* A frequência
  dos /PWMs/ (*na Gen2 todos usam a mesma frequência*) pode ser programada
  entre *24Hz e 1525Hz*. Cada saída do PCA9685 pode *drenar 25mA ou*
  *fornecer 10mA*. Embora o PCA9685 possua 16 canais de /PWM/, apenas 6
  deles estão disponíveis no conector de shield da Galileo Gen2: /pwm1
  (IO3)/, /pwm3 (IO5), pwm5 (IO6), pwm7 (IO9) e pwm11 (IO10)/.

  Os /PWMs/ são acessados no espaço do usuário através da interface
  *sysfs exposta em* /sys/class/pwm/pwmchip0. Neste diretório existem os
  seguintes pseudo-arquivos:

  - *npwm*: O número de canais de /PWM/ suportados
  - *export*: Exporta um canal de /PWM/
  - *unexport*: "Desexporta" um canal de /PWM/
  - *device/pwm_period*: período do /PWM/ em *nanosegundos*. No caso do
    PCA9685 todos os /PWMs/ usam o mesmo período, que deve ser
    programado neste arquivo. (Gen2)
    
    Os canais de /PWM são numerados de 0 a npwm-1.
    Quando um canal de /PWM/ é exportado, será criado um diretório *pwmX*
    dentro de /sys/class/pwm/pwmchip0, onde X é o número do canal
    exportado. Os seguintes *arquivos* existirão no diretório
    /sys/class/pwm/pwmchip0/pwmX:
    
    - *period*: Período do /PWM/ em *nanosegundos*. No caso do PCA9685 todos
      os /PWMs/ usam o mesmo período, portanto este arquivo *não pode ser
      escrito*. O período deve ser configurado através do arquivo
      */sys/class/pwm/pwmchip0/device/pwm_period*, como explicado acima.

    - *duty_cycle*: Duração do ciclo de trabalho do /PWM/ em
      *nanosegundos*. Obviamente, deve ser menor que o período.

    - *polarity*: Troca a polaridade do sinal de /PWM/. Funciona apenas se
      o hardware suportar. A polaridade só pode ser trocada com o /PWM/
      desabilitado. Os valores possíveis são as strings: "normal" ou
      "inversed".

    - *enable*: Habilita/desabilita o /PWM/. "0" desabilita, "1" habilita.

*** Experimentos
    
**** Crie um novo grupo chamado *pwm* e inclua seu usuário nesse grupo.

    #+BEGIN_SRC shell
    groupadd pwm
    usermod -a -G pwm <username>
    #+END_SRC

    
    
**** Verifique o mapeamento dos pinos de GPIO da Galileo
   
   - Para essa etapa, utilizaremos o *pwm3* para acionarmos um LED. Esse
     pino corresponde ao IO5 no conector de shield da Galileo Gen2.

     Após verificarmos a tabela de mapeamento no link:
     https://moodle.ece.ufrgs.br/mod/page/view.php?id=875

     Podemos constatar que os pinos que devem ser configurados são
     *gpio18 e gpio66* como saída e o pino *gpio19* como resistor de
     pull-up.

**** Criando o /script/ de inicialização
* LAB07 (2020-07-16)
** Entendendo o conversor analógico digital da Galileo
 A Galileo possui um conversor A/D de 8 canais, dos quais 6 estão
 disponíveis no shield da Galileo. Na Galileo Gen2 são implementados
 pelo chip ADC108S102 da Texas Instruments, o chip está conectado
 diretamente no Quark X1000 através do barramento SPI 0.

 As entradas do conversor A/D estão mapeadas nos pinos *IO14-IO19* do
 conector de shield. Como nos outros casos, é necessário configurar os
 pinos do conector do shield para ler as medidas corretas do conversor
 A/D. *Note em especial, que o resistor de pull-up/pull-down deve ser*
 *configurado em off para não interferir na medida*. Na Galileo Gen2 a
 resolução A/D é de 10 bits, mas os dados são escalonados para 12 bits
 para serem apresentados na interface do espaço do usuário, isso é
 feito para manter compatibilidade do drive da Galileo Gen1.

 O conversor A/D pode ser usado em dois modos: modo de disparo único e
 modo contínuo. No modo *disparo único* é feita apenas *uma conversão* por
 requisição, enquanto no *modo contínuo*, são feitas conversões em
 sequência em todos canais habilitados.

*** Modo de disparo único

  O acesso aos canais do conversor A/D através do espaço do usuário é
  feito através de arquivos no diretório
  */sys/bus/iio/devices/iio:device:0:*
  
  - *in_voltageN_raw*: Valor bruto da medida em ASCII

  - *in_voltageN_scale*: Multiplicador para converter o valor bruto da
  medida para *mV*

  OBS.: Onde *N* é o número do canal do conversor A/D.

*** Modo contínuo

  Os dados brutos são lidos através do arquivo */dev/iio:device0:* em
  binário. A configuração do buffer para receber os dados e dos canais
  que serão amostrados também é feita através do diretório
  */sys/bys/iio/devices/iio:device:0*

  *- buffer/length:* Número de conjunto de amostras do buffer.

  *- buffer/enable*: Habilita/desabilita as conversões no modo contínuo.

  *- scan_elements/in_timestamp_en:* Habilita o timestamp de dados.

  *- scan_elements/in_timestamp_index:* Índice de posição do timestamp
  no buffer.

  *- scan_elements/in_timestamp_type:* Formato com o qual o timestamp é
  armazenado no buffer.

  *- scan_elements/in_voltageN_en:* Habilita a amostragem do canal N.

  *- scan_elements/in_voltageN_index:* Índice da posição do canal N no
  buffer.

  *- scan_elements/in_voltageN_type:* Formato com o qual os dados do
  canal N serão armazenados no buffer.

  *- trigger/current_trigger:* Configura o trigger a ser usado para
     disparar as conversões.

  O formato dos dados é descrito por uma string no formato:

  <endianness>:<signal><precision>/<size>>><alignment>

  *- endianness:* be - big endian / le - little endian.

  *- signal:* Indica se o valor tem sinal (*s*) ou não (*u*).

  *- precision:* Indica o número de bits com informação relevante.

  *- size:* Indica o número de bits usado para armazenar o dado.

  *- alignment:* Indica o alinhamento dos bits de informação.

  Assim, *be:u12/16>>0* significa que os dados estão em formato big
  endian, sem sinal, com 12 bits de informação, armazenados em 16 bits
  e alinhados no bit 0.

  Para realizar as conversões no modo contínuo, deve-se habilitar os
  canais desejados, configurar o tamanho do buffer (número de
  amostras) e habilitar o buffer. Os pseudo-arquivos com índices são
  de *leitura apenas* e somente os canais habilitados são inseridos no
  buffer.

  As conversões são disparadas por um trigger. Os triggers disponíveis
  aparecem em */sys/bus/iio/devices* quando módulo do kernel
  correspondente é carregado. Estes módulos *não são carregados* no boot
  da Galileo. É necessário carregá-los explicitamente com os comandos
  *modprobe* ou *insmod*. Os triggers disponíveis na Galileo Gen2 são:

  *- iio-trig-sysfs:* Totalmente baseado em software. Permite disparar
  por software cada amostragem, como no modo de disparo único, mas
  com uma API de modo contínuo.

  *- iio-trig-hrtimer:* Baseado no temporizador HPET. Permite configurar
  a frequência com que será feita a amostragem.

  /Quando os módulos de trigger são carregaos, surgem os seguintes/
  /arquivos no diretório/ */sys/bus/iio/devices*:

  *- iio_sysfs_trigger/add_trigger*: Usado para criar um trigger do tipo
  /iio_sysfs_trigger/, ao se escrever um número inteiro positivo no
  arquivo.

  *- iio_sysfs_trigger/remove_trigger:* Usado para remover um trigger do
  tipo /iio_sysfs_trigger/, ao se escrever um número inteiro positivo no
  arquivo.

  *- iio_hrtimer_trigger/add_trigger:* Usado para criar um trigger do
  tipo /iio_hrtimer_trigger/, ao se escrever um número inteiro no arquivo.
 
  *- iio_hrtimer_trigger/remove_trigger:* Usado para remover um trigger
  do tipo /iio_hrtimer_trigger/, ao ao se escrever um número inteiro
  no arquivo.

  Para cada trigger é criado um diretório */sys/bus/iio/devices/trigger<n>*, 
  onde *<n>* é um número crescente a partir de 0. Note que <n> não é o número que
  foi escrito no arquivo *add_trigger* para criação do trigger, mas um número
  que é *incrementado* a cada trigger criado. O conteúdo deste diretório depende do
  tipo do trigger:

  *- name:* Nome do trigger, usado para configurar o trigger a ser usado.

  *- trigger_now:* Qualquer escrita neste arquivo dispara o trigger. Só
  existe para triggers do tipo *iio_sysfs_trigger*.

  *- frequency:* Configura a frequência do trigger. Só existe para
  triggers do tipo *iio_hrtimer_trigger*.

  Quando é usado um trigger do tipo *iio_sysfs_trigger*, após a
  habilitação do *buffer*, cada escrita no arquivo *trigger_now* realiza
  uma amostragem. Quando é usado um trigger do tipo *iio_hrtimer_trigger*,
  a habilitação do buffer inicia a amostragem com a frequência
  programada no arquivo *frequency*. As conversões são paradas
  desabilitando-se o buffer e removendo-se o trigger.

** Experimentos 

 - Criando o grupo /adc/ como super usuário na Galileo:

 #+BEGIN_SRC shell
 groupadd adc
 #+END_SRC

 - Adicionando meu usuário ao grupo

 #+BEGIN_SRC shell
 usermod -a -G adc lucas
 #+END_SRC

 - Para configurar um pino como conversor A/D devemos:

 -- *Habilitar leituras/escritas nos arquivos*

 -- *Desabilitar os resistores de pull-up e pull-down*

 Para desabilitar os resistores de pull-up e pull-down, basta:

 *Colocar o pino como direction "in"*

